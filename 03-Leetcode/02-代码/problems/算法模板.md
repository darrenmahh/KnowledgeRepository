* [做项目（多个C++、Java、Go、测开、前端项目）](https://www.programmercarl.com/other/kstar.html)
* [刷算法（两个月高强度学算法）](https://www.programmercarl.com/xunlian/xunlianying.html)
* [背八股（40天挑战高频面试题）](https://www.programmercarl.com/xunlian/bagu.html)
# 算法模板

## 算法模板

### 二分查找法 

### KMP

### 二叉树 

二叉树的定义：

#### 深度优先遍历（递归） 

前序遍历（中左右）

中序遍历（左中右）

后序遍历（左右中）

#### 深度优先遍历（迭代法）

相关题解：[0094.二叉树的中序遍历](https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.二叉树的中序遍历.md)

前序遍历（中左右）

中序遍历（左中右）

后序遍历（左右中）

#### 广度优先遍历（队列）

相关题解：[0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)

可以直接解决如下题目：

* [0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)
* [0199.二叉树的右视图](https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.二叉树的右视图.md)
* [0637.二叉树的层平均值](https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.二叉树的层平均值.md) 
* [0104.二叉树的最大深度 （迭代法）](https://programmercarl.com/0104.二叉树的最大深度.html)

* [0111.二叉树的最小深度（迭代法）](https://programmercarl.com/0111.二叉树的最小深度.html)
* [0222.完全二叉树的节点个数（迭代法）](https://programmercarl.com/0222.完全二叉树的节点个数.html)

#### 二叉树深度

#### 二叉树节点数量

### 回溯算法 

### 并查集 

（持续补充ing）
## 其他语言版本

### JavaScript：

#### 二分查找法

使用左闭右闭区间

使用左闭右开区间

#### KMP

#### 二叉树

##### 深度优先遍历（递归）

二叉树节点定义：

前序遍历（中左右）：

中序遍历（左中右）：

后序遍历（左右中）：

##### 深度优先遍历（迭代）

前序遍历（中左右）：

中序遍历（左中右）：

后序遍历（左右中）：

##### 广度优先遍历（队列）

##### 二叉树深度

##### 二叉树节点数量

#### 回溯算法 

#### 并查集 

### TypeScript：

#### 二分查找法

使用左闭右闭区间

使用左闭右开区间

#### KMP

#### 二叉树

##### 深度优先遍历（递归）

二叉树节点定义：

前序遍历（中左右）：

中序遍历（左中右）：

后序遍历（左右中）：

##### 深度优先遍历（迭代）

前序遍历（中左右）：

中序遍历（左中右）：

后序遍历（左右中）：

##### 广度优先遍历（队列）

##### 二叉树深度

##### 二叉树节点数量

#### 回溯算法 

#### 并查集 

Java：

### Python：

#### 二分查找法 
```python 
def binarysearch(nums, target):
    low = 0
    high = len(nums) - 1
    while (low <= high):
        mid = (high + low)//2

        if (nums[mid] < target):
            low = mid + 1
            
        if (nums[mid] > target):
            high = mid - 1
            
        if (nums[mid] == target):
            return mid

    return -1
python 
def kmp(self, a, s):
    # a: length of the array
    # s: string 
    
    next = [0]*a
    j = 0    
    next[0] = 0
 
    for i in range(1, len(s)):
        while j > 0 and s[j] != s[i]:
            j = next[j - 1]
            
        if s[j] == s[i]:
            j += 1
        next[i] = j
    return next 
```

Go：


* [做项目（多个C++、Java、Go、测开、前端项目）](https://www.programmercarl.com/other/kstar.html)
* [刷算法（两个月高强度学算法）](https://www.programmercarl.com/xunlian/xunlianying.html)
* [背八股（40天挑战高频面试题）](https://www.programmercarl.com/xunlian/bagu.html)

# 100. 相同的树

[力扣题目链接](https://leetcode.cn/problems/same-tree/)

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

![](https://file1.kamacoder.com/i/algo/20210726172932.png)

![](https://file1.kamacoder.com/i/algo/20210726173011.png)

## 思路

在[101.对称二叉树](https://programmercarl.com/0101.对称二叉树.html)中，我们讲到对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

理解这一本质之后，就会发现，求二叉树是否对称，和求二叉树是否相同几乎是同一道题目。

**如果没有读过[二叉树：我对称么？](https://programmercarl.com/0101.对称二叉树.html)这一篇，请认真读完再做这道题，就会有感觉了。**

递归三部曲中：

1. 确定递归函数的参数和返回值

我们要比较的是两个树是否是相互相同的，参数也就是两个树的根节点。

返回值自然是bool类型。

代码如下：

分析过程同[101.对称二叉树](https://programmercarl.com/0101.对称二叉树.html)。

2. 确定终止条件

**要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。**

节点为空的情况有：

* tree1为空，tree2不为空，不对称，return false
* tree1不为空，tree2为空，不对称 return  false
* tree1，tree2都为空，对称，返回true

此时已经排除掉了节点为空的情况，那么剩下的就是tree1和tree2不为空的时候：

* tree1、tree2都不为空，比较节点数值，不相同就return false

此时tree1、tree2节点不为空，且数值也不相同的情况我们也处理了。

代码如下：

分析过程同[101.对称二叉树](https://programmercarl.com/0101.对称二叉树.html)

3. 确定单层递归的逻辑

* 比较二叉树是否相同 ：传入的是tree1的左孩子，tree2的右孩子。
* 如果左右都相同就返回true ，有一侧不相同就返回false 。

代码如下：

最后递归的C++整体代码如下：

**我给出的代码并不简洁，但是把每一步判断的逻辑都清楚的描绘出来了。**

如果上来就看网上各种简洁的代码，看起来真的很简单，但是很多逻辑都掩盖掉了，而题解可能也没有把掩盖掉的逻辑说清楚。

**盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。**

当然我可以把如上代码整理如下：

### 递归

### 迭代法

## 其他语言版本

### Java：

```java
// 递归法
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        else if (q == null || p == null) return false;
        else if (q.val != p.val) return false;
        return isSameTree(q.left, p.left) && isSameTree(q.right, p.right);
    }
}
```

```java
// 迭代法
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null || q == null) return false;
        Queue<TreeNode> que= new LinkedList<TreeNode>();
        que.offer(p);
        que.offer(q);
        while(!que.isEmpty()){
            TreeNode leftNode = que.poll();
            TreeNode rightNode = que.poll();
            if(leftNode == null && rightNode == null) continue;
            if(leftNode == null || rightNode== null || leftNode.val != rightNode.val) return false;
            que.offer(leftNode.left);
            que.offer(rightNode.left);
            que.offer(leftNode.right);
            que.offer(rightNode.right);
        }
        return true;
    }
}
```
### Python：

### Go：

> 递归法

### JavaScript：

> 递归法

> 迭代法

### TypeScript:

> 递归法-先序遍历

> 迭代法-层序遍历


* [做项目（多个C++、Java、Go、测开、前端项目）](https://www.programmercarl.com/other/kstar.html)
* [刷算法（两个月高强度学算法）](https://www.programmercarl.com/xunlian/xunlianying.html)
* [背八股（40天挑战高频面试题）](https://www.programmercarl.com/xunlian/bagu.html)

# 234.回文链表

[力扣题目链接](https://leetcode.cn/problems/palindrome-linked-list/)

请判断一个链表是否为回文链表。

示例 1:
* 输入: 1->2
* 输出: false

示例 2:
* 输入: 1->2->2->1
* 输出: true

## 思路

### 数组模拟

最直接的想法，就是把链表装成数组，然后再判断是否回文。

代码也比较简单。如下：

上面代码可以在优化，就是先求出链表长度，然后给定vector的初始长度，这样避免vector每次添加节点重新开辟空间

### 反转后半部分链表

分为如下几步：

* 用快慢指针，快指针有两步，慢指针走一步，快指针遇到终止位置时，慢指针就在链表中间位置
* 同时用pre记录慢指针指向节点的前一个节点，用来分割链表
* 将链表分为前后均等两部分，如果链表长度是奇数，那么后半部分多一个节点
* 将后半部分反转 ，得cur2，前半部分为cur1
* 按照cur1的长度，一次比较cur1和cur2的节点数值

如图所示：

<img src='https://file1.kamacoder.com/i/algo/234.回文链表.png' width=600> </img></div>

代码如下：

## 其他语言版本

### Java

```java
// 方法一，使用数组
class Solution {
    public boolean isPalindrome(ListNode head) {
        int len = 0;
        // 统计链表长度
        ListNode cur = head;
        while (cur != null) {
            len++;
            cur = cur.next;
        }
        cur = head;
        int[] res = new int[len];
        // 将元素加到数组之中
        for (int i = 0; i < res.length; i++){
            res[i] = cur.val;
            cur = cur.next;
        }
        // 比较回文
        for (int i = 0, j = len - 1; i < j; i++, j--){
            if (res[i] != res[j]){
                return false;
            }
        }
        return true;
    }
}

// 方法二，快慢指针
class Solution {
    public boolean isPalindrome(ListNode head) {
        // 如果为空或者仅有一个节点，返回true
        if (head == null && head.next == null) return true;
        ListNode slow = head;
        ListNode fast = head;
        ListNode pre = head;
        while (fast != null && fast.next != null){
            pre = slow;  // 记录slow的前一个结点
            slow = slow.next;
            fast = fast.next.next;
        }
        pre.next = null;  // 分割两个链表

        // 前半部分
        ListNode cur1 = head;
        // 后半部分。这里使用了反转链表
        ListNode cur2 = reverseList(slow);

        while (cur1 != null){
            if (cur1.val != cur2.val) return false;

            // 注意要移动两个结点
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head){
        // 反转链表
        ListNode tmp = null;
        ListNode pre = null;
        while (head != null){
            tmp = head.next;
            head.next = pre;
            pre = head;
            head = tmp;
        }
        return pre;
    }
}
```

### Python

### Go

### JavaScript

### TypeScript

> 数组模拟

> 反转后半部分链表


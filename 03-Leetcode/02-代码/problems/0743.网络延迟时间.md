* [做项目（多个C++、Java、Go、测开、前端项目）](https://www.programmercarl.com/other/kstar.html)
* [刷算法（两个月高强度学算法）](https://www.programmercarl.com/xunlian/xunlianying.html)
* [背八股（40天挑战高频面试题）](https://www.programmercarl.com/xunlian/bagu.html)

# 743.网络延迟时间 

https://leetcode.cn/problems/network-delay-time/description/ 

有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

![](https://file1.kamacoder.com/i/algo/20240229104105.png)

提示：

* 1 <= k <= n <= 100
* 1 <= times.length <= 6000
* times[i].length == 3
* 1 <= ui, vi <= n
* ui != vi
* 0 <= wi <= 100
* 所有 (ui, vi) 对都 互不相同（即，不含重复边）

# dijkstra 精讲

本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。 

接下来，我们来详细讲解最短路算法中的 dijkstra 算法。

dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。

需要注意两点： 

* dijkstra 算法可以同时求 起点到所有节点的最短路径
* 权值不能为负数 

（这两点后面我们会讲到）

如本题示例中的图：

![](https://file1.kamacoder.com/i/algo/20240125162647.png)

起点（节点1）到终点（节点7） 的最短路径是 图中 标记绿线的部分。

最短路径的权值为12。 

其实 dijkstra 算法  和 我们之前讲解的prim算法思路非常接近，如果大家认真学过[prim算法](https://mp.weixin.qq.com/s/yX936hHC6Z10K36Vm1Wl9w)，那么理解 Dijkstra 算法会相对容易很多。（这也是我要先讲prim再讲dijkstra的原因）

dijkstra 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。 

这里我也给出 **dijkstra三部曲**：

1. 第一步，选源点到哪个节点近且该节点未被访问过
2. 第二步，该最近节点被标记访问过
3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）

大家此时已经会发现，这和prim算法 怎么这么像呢。 

我在[prim算法](https://mp.weixin.qq.com/s/yX936hHC6Z10K36Vm1Wl9w)讲解中也给出了三部曲。 prim 和 dijkstra 确实很像，思路也是类似的，这一点我在后面还会详细来讲。

在dijkstra算法中，同样有一个数组很重要，起名为：minDist。 

**minDist数组 用来记录 每一个节点距离源点的最小距离**。 

理解这一点很重要，也是理解 dijkstra 算法的核心所在。 

大家现在看着可能有点懵，不知道什么意思。

没关系，先让大家有一个印象，对理解后面讲解有帮助。

我们先来画图看一下 dijkstra 的工作过程，以本题示例为例： （以下为朴素版dijkstra的思路） 

（**示例中节点编号是从1开始，所以为了让大家看的不晕，minDist数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混**）

## 朴素版dijkstra 

### 模拟过程

----------- 

0、初始化

minDist数组数值初始化为int最大值。 

这里在强点一下 **minDist数组的含义：记录所有节点到源点的最短路径**，那么初始化的时候就应该初始为最大值，这样才能在后续出现最短路径的时候及时更新。 

![](https://file1.kamacoder.com/i/algo/20240130115306.png)

（图中，max 表示默认值，节点0 不做处理，统一从下标1 开始计算，这样下标和节点数值统一， 方便大家理解，避免搞混） 

源点（节点1） 到自己的距离为0，所以 minDist[1] = 0

此时所有节点都没有被访问过，所以 visited数组都为0

--------------- 

以下为dijkstra 三部曲

1、选源点到哪个节点近且该节点未被访问过

源点距离源点最近，距离为0，且未被访问。 

2、该最近节点被标记访问过 

标记源点访问过 

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240130115421.png)

更新 minDist数组，即：源点（节点1） 到 节点2 和 节点3的距离。 

* 源点到节点2的最短距离为1，小于原minDist[2]的数值max，更新minDist[2] = 1 
* 源点到节点3的最短距离为4，小于原minDist[3]的数值max，更新minDist[4] = 4 

可能有录友问：为啥和 minDist[2] 比较？

再强调一下 minDist[2] 的含义，它表示源点到节点2的最短距离，那么目前我们得到了 源点到节点2的最短距离为1，小于默认值max，所以更新。 minDist[3]的更新同理

-------------

1、选源点到哪个节点近且该节点未被访问过

未访问过的节点中，源点到节点2距离最近，选节点2 

2、该最近节点被标记访问过 

节点2被标记访问过

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240130121240.png)

更新 minDist数组，即：源点（节点1） 到 节点6 、 节点3 和 节点4的距离。 

**为什么更新这些节点呢？ 怎么不更新其他节点呢**？

因为 源点（节点1）通过 已经计算过的节点（节点2） 可以链接到的节点 有 节点3，节点4和节点6. 

更新  minDist数组： 

* 源点到节点6的最短距离为5，小于原minDist[6]的数值max，更新minDist[6] = 5 
* 源点到节点3的最短距离为3，小于原minDist[3]的数值4，更新minDist[3] = 3 
* 源点到节点4的最短距离为6，小于原minDist[4]的数值max，更新minDist[4] = 6 

-------------------

1、选源点到哪个节点近且该节点未被访问过

未访问过的节点中，源点距离哪些节点最近，怎么算的？  

其实就是看 minDist数组里的数值，minDist 记录了 源点到所有节点的最近距离，结合visited数组筛选出未访问的节点就好。 

从 上面的图，或者 从minDist数组中，我们都能看出 未访问过的节点中，源点（节点1）到节点3距离最近。 

2、该最近节点被标记访问过 

节点3被标记访问过

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240130120434.png)

由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新minDist数组： 

更新  minDist数组： 

* 源点到节点4的最短距离为5，小于原minDist[4]的数值6，更新minDist[4] = 5 

------------------

1、选源点到哪个节点近且该节点未被访问过

距离源点最近且没有被访问过的节点，有节点4 和 节点6，距离源点距离都是 5 （minDist[4] = 5，minDist[6] = 5） ，选哪个节点都可以。 

2、该最近节点被标记访问过 

节点4被标记访问过

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240201105335.png) 

由于节点4的加入，那么源点可以链接到节点5 所以更新minDist数组： 

* 源点到节点5的最短距离为8，小于原minDist[5]的数值max，更新minDist[5] = 8 

--------------

1、选源点到哪个节点近且该节点未被访问过

距离源点最近且没有被访问过的节点，是节点6，距离源点距离是 5 （minDist[6] = 5）  

2、该最近节点被标记访问过 

节点6 被标记访问过

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240201110250.png)

由于节点6的加入，那么源点可以链接到节点7 所以 更新minDist数组： 

* 源点到节点7的最短距离为14，小于原minDist[7]的数值max，更新minDist[7] = 14 

-------------------

1、选源点到哪个节点近且该节点未被访问过

距离源点最近且没有被访问过的节点，是节点5，距离源点距离是 8 （minDist[5] = 8）  

2、该最近节点被标记访问过 

节点5 被标记访问过

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240201110651.png) 

由于节点5的加入，那么源点有新的路径可以链接到节点7 所以 更新minDist数组： 

* 源点到节点7的最短距离为12，小于原minDist[7]的数值14，更新minDist[7] = 12 

-----------------

1、选源点到哪个节点近且该节点未被访问过

距离源点最近且没有被访问过的节点，是节点7（终点），距离源点距离是 12 （minDist[7] = 12）  

2、该最近节点被标记访问过 

节点7 被标记访问过

3、更新非访问节点到源点的距离（即更新minDist数组） ，如图： 

![](https://file1.kamacoder.com/i/algo/20240201110920.png)

节点7加入，但节点7到节点7的距离为0，所以 不用更新minDist数组 

--------------------

最后我们要求起点（节点1） 到终点 （节点7）的距离。 

再来回顾一下minDist数组的含义：记录 每一个节点距离源点的最小距离。  

那么起到（节点1）到终点（节点7）的最短距离就是 minDist[7] ，按上面举例讲解来说，minDist[7] = 12，节点1 到节点7的最短路径为 12。

路径如图： 

![](https://file1.kamacoder.com/i/algo/20240201111352.png) 

在上面的讲解中，每一步 我都是按照 dijkstra 三部曲来讲解的，理解了这三部曲，代码也就好懂的。 

### 代码实现

本题代码如下，里面的 三部曲 我都做了注释，大家按照我上面的讲解 来看如下代码：

```CPP 
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {

        // 注意题目中给的二维数组并不是领接矩阵
        // 需要邻接矩阵来存图
        // 因为本题处理方式是节点标号从1开始，所以数组的大小都是 n+1
        vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));
        for(int i = 0; i < times.size(); i++){
            int p1 = times[i][0];
            int p2 = times[i][1];
            grid[p1][p2] = times[i][2];
        }

        // 存储从源点到每个节点的最短距离
        std::vector<int> minDist(n + 1, INT_MAX);  

        // 记录顶点是否被访问过
        std::vector<bool> visited(n + 1, false); 

        minDist[k] = 0;  // 起始点到自身的距离为0
        for (int i = 1; i <= n; i++) {

            int minVal = INT_MAX;
            int cur = 1;

            // 遍历每个节点，选择未被访问的节点集合中哪个节点到源点的距离最小
            for (int v = 1; v <= n; ++v) {
                if (!visited[v] && minDist[v] <= minVal) {
                    minVal = minDist[v];
                    cur = v;
                }
            }

            visited[cur] = true;  // 标记该顶点已被访问

            for (int v = 1; v <= n; v++) {
                if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
                    minDist[v] = minDist[cur] + grid[cur][v];
                }
            }

        }
        // 源点到最远的节点的时间，也就是寻找 源点到所有节点最短路径的最大值 
        int result = 0;
        for (int i = 1; i <= n; i++) {
            if (minDist[i] == INT_MAX) return -1;// 没有路径
            result = max(minDist[i], result);
        }
        return result;

    }
};
CPP 
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {

        // 注意题目中给的二维数组并不是领接矩阵
        // 需要邻接矩阵来存图
        // 因为本题处理方式是节点标号从1开始，所以数组的大小都是 n+1
        vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));
        for(int i = 0; i < times.size(); i++){
            int p1 = times[i][0];
            int p2 = times[i][1];
            grid[p1][p2] = times[i][2];
        }

        // 存储从源点到每个节点的最短距离
        std::vector<int> minDist(n + 1, INT_MAX);

        // 记录顶点是否被访问过
        std::vector<bool> visited(n + 1, false);

        minDist[k] = 0;  // 起始点到自身的距离为0
        for (int i = 1; i <= n; i++) {

            int minVal = INT_MAX;
            int cur = 1;

            // 遍历每个节点，选择未被访问的节点集合中哪个节点到源点的距离最小
            for (int v = 1; v <= n; ++v) {
                if (!visited[v] && minDist[v] <= minVal) {
                    minVal = minDist[v];
                    cur = v;
                }
            }

            visited[cur] = true;  // 标记该顶点已被访问

            for (int v = 1; v <= n; v++) {
                if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
                    minDist[v] = minDist[cur] + grid[cur][v];
                }
            }
            // 打印日志：
            cout << "select:" << cur << endl;
            for (int v = 1; v <= n; v++) cout <<  v << ":" << minDist[v] << " ";
            cout << endl << endl;;

        }
        // 源点到最远的节点的时间，也就是寻找 源点到所有节点最短路径的最大值
        int result = 0;
        for (int i = 1; i <= n; i++) {
            if (minDist[i] == INT_MAX) return -1;// 没有路径
            result = max(minDist[i], result);
        }
        return result;

    }
};

select:2
1:1 2:0 3:1 4:2147483647

select:3
1:1 2:0 3:1 4:2

select:1
1:1 2:0 3:1 4:2

select:4
1:1 2:0 3:1 4:2
CPP 
for (int j = 1; j <= v; j++) {
    if (!isInTree[j] && grid[cur][j] < minDist[j]) {
        minDist[j] = grid[cur][j];
    }
}
CPP 
for (int v = 1; v <= n; v++) {
    if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
        minDist[v] = minDist[cur] + grid[cur][v];
    }
}
CPP 

for (int i = 1; i <= n; i++) { // 遍历所有节点，第一层for循环 

    int minVal = INT_MAX;
    int cur = 1;

    // 1、选距离源点最近且未访问过的节点 ， 第二层for循环
    for (int v = 1; v <= n; ++v) {
        if (!visited[v] && minDist[v] < minVal) {
            minVal = minDist[v];
            cur = v;
        }
    }

    visited[cur] = true;  // 2、标记该节点已被访问

    // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）
    for (int v = 1; v <= n; v++) {
        if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
            minDist[v] = minDist[cur] + grid[cur][v];
        }
    }

}
CPP 
vector<list<int>> grid(n + 1);
CPP 
vector<list<pair<int,int>>> grid(n + 1);
CPP
struct Edge {
    int to;  // 邻接顶点
    int val; // 边的权重

    Edge(int t, int w): to(t), val(w) {}  // 构造函数
};
CPP 
struct Edge {
    int to;  // 链接的节点
    int val; // 边的权重

    Edge(int t, int w): to(t), val(w) {}  // 构造函数
};

vector<list<Edge>> grid(n + 1); // 邻接表

CPP 
// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};
// 优先队列中存放 pair<节点编号，源点到该节点的权值> 
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;
CPP 
// pair<节点编号，源点到该节点的权值>
pair<int, int> cur = pq.top(); pq.pop();

CPP 
// 2. 第二步，该最近节点被标记访问过
visited[cur.first] = true;

CPP 

// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）
for (int v = 1; v <= n; v++) {
    if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
        minDist[v] = minDist[cur] + grid[cur][v];
    }
}
CPP 
for (Edge edge : grid[cur.first]) 
CPP 
// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）
for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge
    // cur指向的节点edge.to，这条边的权值为 edge.val
    if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist
        minDist[edge.to] = minDist[cur.first] + edge.val;
        pq.push(pair<int, int>(edge.to, minDist[edge.to]));
    }
}
CPP 
struct Edge {
    int to;  // 邻接顶点
    int val; // 边的权重

    Edge(int t, int w): to(t), val(w) {}  // 构造函数
};
CPP 
if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist
    minDist[edge.to] = minDist[cur.first] + edge.val;
    pq.push(pair<int, int>(edge.to, minDist[edge.to])); // 由于cur节点的加入，而新链接的边，加入到优先级队里中
}

CPP
class Solution {
public:
    // 小顶堆
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    // 定义一个结构体来表示带权重的边
    struct Edge {
        int to;  // 邻接顶点
        int val; // 边的权重

        Edge(int t, int w): to(t), val(w) {}  // 构造函数
    };
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {

        std::vector<std::list<Edge>> grid(n + 1);
        for(int i = 0; i < times.size(); i++){
            int p1 = times[i][0];
            int p2 = times[i][1];
            // p1 指向 p2，权值为 times[i][2]
            grid[p1].push_back(Edge(p2, times[i][2]));
        }

        // 存储从源点到每个节点的最短距离
        std::vector<int> minDist(n + 1, INT_MAX);

        // 记录顶点是否被访问过
        std::vector<bool> visited(n + 1, false);

        // 优先队列中存放 pair<节点，源点到该节点的距离>
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;

        pq.push(pair<int, int>(k, 0));
        minDist[k] = 0; // 这个不要忘了

        while (!pq.empty()) {
            // <节点， 源点到该节点的距离>
            // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）
            pair<int, int> cur = pq.top(); pq.pop();

            if (visited[cur.first]) continue;

            // 2. 第二步，该最近节点被标记访问过
            visited[cur.first] = true;

            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）
            for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge
                // cur指向的节点edge.to，这条边的权值为 edge.val
                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist
                    minDist[edge.to] = minDist[cur.first] + edge.val;
                    pq.push(pair<int, int>(edge.to, minDist[edge.to]));
                }
            }

        }

        // 源点到最远的节点的时间，也就是寻找 源点到所有节点最短路径的最大值
        int result = 0;
        for (int i = 1; i <= n; i++) {
            if (minDist[i] == INT_MAX) return -1;// 没有路径
            result = max(minDist[i], result);
        }
        return result;

    }
};

CPP
class Solution {
public:
    // 小顶堆（按照<k ,v>中的v 来从小到大排序）
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {

        // 注意题目中给的二维数组并不是邻接矩阵
        // 需要邻接矩阵来存图
        // 因为本题处理方式是节点标号从1开始，所以数组的大小都是 n+1
        vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));
        for(int i = 0; i < times.size(); i++){
            int p1 = times[i][0];
            int p2 = times[i][1];
            grid[p1][p2] = times[i][2];
        }

        // 存储从源点到每个节点的最短距离
        std::vector<int> minDist(n + 1, INT_MAX);

        // 记录顶点是否被访问过
        std::vector<bool> visited(n + 1, false);

        // 优先队列中存放 [节点，源点到该节点的距离]
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;

        pq.push(pair<int, int>(k, 0));
        minDist[k] = 0; // 这个不要忘了

        while (!pq.empty()) {
            // <节点， 源点到该节点的距离>
            // 1、选距离源点最近且未访问过的节点
            pair<int, int> cur = pq.top(); pq.pop();

            if (visited[cur.first]) continue;

            // 2、标记该节点已被访问
            visited[cur.first] = true;

            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）
            // 遍历 cur 可以链接的节点，更新 minDist[j] 
            for (int j = 1; j <= n; j++) {
                if (!visited[j] && grid[cur.first][j] != INT_MAX && (minDist[cur.first] + grid[cur.first][j] < minDist[j])) {
                    minDist[j] = minDist[cur.first] + grid[cur.first][j];
                    pq.push(pair<int, int>(j, minDist[j]));
                }
            }
        }

        // 源点到最远的节点的时间，也就是寻找 源点到所有节点最短路径的最大值
        int result = 0;
        for (int i = 1; i <= n; i++) {
            if (minDist[i] == INT_MAX) return -1;// 没有路径
            result = max(minDist[i], result);
        }

        return result;

    }
};

CPP 
class Solution {
public:

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<int> minDist(n + 1 , INT_MAX/2);
        minDist[k] = 0;
        //vector<int> minDist_copy(n); // 用来记录每一次遍历的结果
        for (int i = 1; i <= n + 1; i++) {
            //minDist_copy = minDist; // 获取上一次计算的结果
            for (auto &f : times) {
                int from = f[0];
                int to = f[1];
                int price = f[2];
                if (minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;
            }

        }
        int result = 0;
        for (int i = 1;i <= n; i++) {
            if (minDist[i] == INT_MAX/2) return -1;// 没有路径
            result = max(minDist[i], result);
        }
        return result;

    }
};
```


# 1 MQ有什么用/为什么要使用MQ⭐⭐⭐
<div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">消息队列的本质其实就是一个阻塞队列，只是在阻塞队列的基础上增加了重试、消息持久化等功能。主要功能有三个：</div>
- 异步：
	- A系统接收请求后需要在BCD三个系统同时写入
	- 不使用的话就需要全部写完之后再返回给用户
	- 但是使用消息队列就意味着A把消息发给BCD后就返回
- 削峰：
	- 订单系统中，业务高峰期，下单的太多，那就把生成订单的id放在MQ中，消息都堆在MQ中，这就是<mark style="background: #FF5582A6;">削峰</mark>
	- 然后让其他和新线程监听MQ，然后慢慢异步进行订单创建等操作，这些业务会持续到业务的平谷期，所以叫<mark style="background: #FF5582A6;">平谷</mark>。
- 解耦：
	- 如果E也要这个数据的话，那就需要修改A的发送逻辑，这样的话A和其他系统是<mark style="background: #FFB8EBA6;">严重耦合</mark>
	- 现在A可以直接发给MQ，之后谁想要谁去拿

# 2 MQ优缺点 ⭐⭐⭐
- 优点：异步 削峰 平谷
- 缺点：
	- <mark style="background: #FFB8EBA6;">系统可用性降低</mark>：新引入了MQ，那如果MQ挂了，相关服务就崩了
	- <mark style="background: #FFB8EBA6;">系统复杂度提高了</mark>：加了MQ之后，怎么保证消息没有重复消费？怎么保证消息传递顺序性？怎么处理消息丢失？
	- <mark style="background: #FFB8EBA6;">数据一致性问题</mark>：A发送完就返回了，那要是BCD处理失败了，或者有的失败有的成功呢？这时的数据不一致怎么解决？

# 3 如何保证消息可靠性 ⭐⭐⭐
- 消息丢失的情况：
	- <mark style="background: #FF5582A6;">发送时丢失</mark>：
		- 生产者->交换机：<mark style="background: #FFB8EBA6;">confirm机制</mark>
			- 投递成功：返回ack
			- 投递失败：返回nack
			- 在生产者那里开启confirm后，每次的消息都会分配一个唯一的ID，写入之后就回传ack
		- 交换机->消费者：<mark style="background: #FFB8EBA6;">return机制</mark>
			- 消息到了交换机但是没有到队列。就返回ack和路由失败原因
	- <mark style="background: #FF5582A6;">MQ宕机</mark>：<mark style="background: #FFB8EBA6;">消息持久化</mark>以及MQ集群，保证高可用
		- 消息写入队列后开启持久化，就会持久到磁盘
	- <mark style="background: #FF5582A6;">消费时丢失</mark>：<mark style="background: #FFB8EBA6;">消费者手动ACK</mark>
		- 消费者处理之后可以向消费队列发送ack回执，收到后才会删除这条消息

# 4 死信队列？如何导致死信队列⭐⭐
- 死信：就是不能被消费的信息，满足下列条件之一时，就成为了死信
	- 消息被消费者拒绝
	- 消息超时到期，无人消费
	- 要投递的队列消息满了，最早的可能会成为死信
- <mark style="background: #FFB8EBA6;">死信交换机</mark>：如果一个队列配置了dead-letter-exchange属性，制定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机成为死信交换机（Dead Letter Exchange，简称DLX）。
- 死信队列：处理异常的机制，可以捕获那些无法被正常消费的信息，并为这些信息提供一个“兜底”的解决方案。并且可以处理超时无人消费以及队列满了的问题。

# 5 延时队列 ⭐⭐
- 延迟队列是指消息发送后到MQ不会立即被消费，MQ会存储对应的延迟信息，而是等待特定时间后，消费者才能拿到这个消息
- 比如：订单的超时取消，订单被放在MQ中，30分钟未支付订单就取消。如果使用，那监听MQ的消费者从MQ中直接拿到的就是超时的订单，可以直接取消
- 主流MQ都支持延时队列 RocketMQ、RabbitMQ、Pulsar、Kafka。RabbitMQ需要TTL机制模拟延迟队列。

# 6 RabbitMQ使用TTL机制模拟延时队列⭐⭐
- 在一个不被
# 1 MQ有什么用/为什么要使用MQ⭐⭐⭐
<div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">消息队列的本质其实就是一个阻塞队列，只是在阻塞队列的基础上增加了重试、消息持久化等功能。主要功能有三个：</div>
- 异步：
	- A系统接收请求后需要在BCD三个系统同时写入
	- 不使用的话就需要全部写完之后再返回给用户
	- 但是使用消息队列就意味着A把消息发给BCD后就返回
- 削峰：
	- 订单系统中，业务高峰期，下单的太多，那就把生成订单的id放在MQ中，消息都堆在MQ中，这就是<mark style="background: #FF5582A6;">削峰</mark>
	- 然后让其他和新线程监听MQ，然后慢慢异步进行订单创建等操作，这些业务会持续到业务的平谷期，所以叫<mark style="background: #FF5582A6;">平谷</mark>。
- 解耦：
	- 如果E也要这个数据的话，那就需要修改A的发送逻辑，这样的话A和其他系统是<mark style="background: #FFB8EBA6;">严重耦合</mark>
	- 现在A可以直接发给MQ，之后谁想要谁去拿

# 2 MQ优缺点 ⭐⭐⭐
- 优点：异步 削峰 平谷
- 缺点：
	- <mark style="background: #FFB8EBA6;">系统可用性降低</mark>：新引入了MQ，那如果MQ挂了，相关服务就崩了
	- <mark style="background: #FFB8EBA6;">系统复杂度提高了</mark>：加了MQ之后，怎么保证消息没有重复消费？怎么保证消息传递顺序性？怎么处理消息丢失？
	- <mark style="background: #FFB8EBA6;">数据一致性问题</mark>：A发送完就返回了，那要是BCD处理失败了，或者有的失败有的成功呢？这时的数据不一致怎么解决？

# 3 如何保证消息可靠性 ⭐⭐⭐
- 消息丢失的情况：
	- <mark style="background: #FF5582A6;">发送时丢失</mark>：
		- 生产者->交换机：<mark style="background: #FFB8EBA6;">confirm机制</mark>
			- 投递成功：返回ack
			- 投递失败：返回nack
			- 在生产者那里开启confirm后，每次的消息都会分配一个唯一的ID，写入之后就回传ack
		- 交换机->消费者：<mark style="background: #FFB8EBA6;">return机制</mark>
			- 消息到了交换机但是没有到队列。就返回ack和路由失败原因
	- <mark style="background: #FF5582A6;">MQ宕机</mark>：<mark style="background: #FFB8EBA6;">消息持久化</mark>以及MQ集群，保证高可用
		- 消息写入队列后开启持久化，就会持久到磁盘
	- <mark style="background: #FF5582A6;">消费时丢失</mark>：<mark style="background: #FFB8EBA6;">消费者手动ACK</mark>
		- 消费者处理之后可以向消费队列发送ack回执，收到后才会删除这条消息

# 4 死信队列？如何导致死信队列⭐⭐
- 死信：就是不能被消费的信息，满足下列条件之一时，就成为了死信
	- 消息被消费者拒绝
	- 消息超时到期，无人消费
	- 要投递的队列消息满了，最早的可能会成为死信
- <mark style="background: #FFB8EBA6;">死信交换机</mark>：如果一个队列配置了dead-letter-exchange属性，制定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机成为死信交换机（Dead Letter Exchange，简称DLX）。
- 死信队列：处理异常的机制，可以捕获那些无法被正常消费的信息，并为这些信息提供一个“兜底”的解决方案。并且可以处理超时无人消费以及队列满了的问题。

# 5 延时队列 ⭐⭐
- 延迟队列是指消息发送后到MQ不会立即被消费，MQ会存储对应的延迟信息，而是等待特定时间后，消费者才能拿到这个消息
- 比如：订单的超时取消，订单被放在MQ中，30分钟未支付订单就取消。如果使用，那监听MQ的消费者从MQ中直接拿到的就是超时的订单，可以直接取消
- 主流MQ都支持延时队列 RocketMQ、RabbitMQ、Pulsar、Kafka。RabbitMQ需要TTL机制模拟延迟队列。

# 6 RabbitMQ使用TTL机制模拟延时队列⭐⭐
- TTL是一个消息的存活时间，RabbitMQ可以分别设置消息存活时间
- 创建队列A的时候可以设置队列中消息的存活时间TTL，当生产者发送消息进入队列A并且在存活时间内没有被消费，则此消息就会从当前队列移除。
- 当TTL结束之后，我们可以指定当前队列A的消息转存到的队列B
- 那么在消费者监听队列B，从队列B中得到的消息就是延迟消息了


# 7 消息的幂等性 ⭐⭐⭐
- 也就是如何解决消息的重复性
- 幂等性就是如何在队列中判断这个消息的唯一性
	- <mark style="background: #FFB8EBA6;">唯一约束</mark>：如果从MQ拿到的数据是要存到数据库，那么可以根据数据创建唯一约束
		- 同样的数据再次从MQ发送过来的时候，当插入数据库的时候会报唯一约束，不会插入成功
		- 或者先查一次，是否在数据库中保存了，如果能查到就直接丢弃
	- <mark style="background: #FFB8EBA6;">消息唯一ID</mark>：
		- 生产者发送消息的时候，每条消息加一个全局的唯一ID
		- 消费时，将该ID保存到redis
		- 下次消费时查一下redis

# 8 消息积压 ⭐⭐
- <mark style="background: #FFB8EBA6;">消息积压</mark>：生产者发送消息的速度超过了消费者处理信息的速度，或者消费者因为某些原因持续阻塞，就会导致队列中的消息堆积，直到队列存储消息达到上限。最早接收到的就会成为死信，直接被丢弃。
- 解决方案：
	- 增加消费者，提高消费速度
	- 提高单个消费者的处理能力，在消费者开启线程池加快消息处理速度
		- 缺点：消息太多就会开启太多新线程，cpu压力大

## 8.1 如果是bug导致几百万消息持续积压几小时，如何处理：
1. 先修复consumer的bug，以确保其恢复消费速度，然后停掉现有的consumer
2. 新建一个topic，partition是原来的十倍，临时建立好原先十倍的queue数量
3. 写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建好的十倍数量的queue
4. 接着临时征用十倍的机器部署consumer，每一批消费一个临时的queue
5. 这种做法相当于是临时将queue和consumer资源扩大十倍，以正常的十倍消费数据
6. 等快速消费完之后，就恢复之前的结构，重新用原先的consumer消费信息

# 9 如何保证消息的顺序性
（适用于RabbitMQ，RocketMQ和Kafka不一样）
## 9.1 为何需要保证顺序
- 对一个数据的操作有先后顺序，若是不按顺序来会出现数据异常
## 9.2 出现顺序错乱的场景
- 一个queue但是有多个消费者，各个消费者之间执行速度不一样
## 9.3 如何保证顺序
- 拆分多个queue，每一个对应一个consumer
	- 缺点：会使队列变多，造成吞吐量下降
	- 可以在消费者内部使用多线程的方式消费
- ---
- kafka：通过分区和有序消费保证分区内消息顺序性，只要生产者将相关消息发送到一个分区，就可以保证顺序
- RocketMQ：支持顺序消息，发送到特定队列就可以保证
# 1 Redis 核心知识体系总结 (阶段一)

## 1.1 一、高性能探源：Redis 为何如此之快？

### 1.1.1 纯内存操作

- **核心原理**: Redis 是一个纯内存数据库，所有数据读写都在内存中完成，从根本上消除了磁盘 I/O 的性能瓶颈。
    
- **优势**: 微秒级的超低延迟，为上层各种高效操作提供了物理基础。
    

### 1.1.2 单线程模型

- **核心原理**: Redis 的命令处理和执行由一个主线程串行完成。
    
- **优势**:
    
    - 避免了多线程环境中复杂的锁竞争和同步开销。
        
    - 消除了线程上下文切换带来的性能损耗。
        
- **弱点**: 惧怕高时间复杂度的“慢命令”（如 `KEYS *`, `HGETALL` 大哈希等），会导致整个请求队列阻塞。
    

### 1.1.3 I/O 多路复用

- **核心原理**: 利用 `epoll` 等机制，允许单个线程同时监听大量网络连接（Socket）。只有当某个连接“就绪”（有数据可读/可写）时，线程才会被唤醒去处理，从不浪费时间在“等待”上。
    
- **作用**: 完美解决了“单线程”如何应对“高并发连接”的难题，是 Redis 网络层面高效的基石。
    

## 1.2 二、核心数据结构

### 1.2.1 String (字符串)

- **特点**: 最基础的 key-value 结构，value 可以是字符串、数字或二进制数据。
    
- **场景**: 缓存单个值、原子计数器 (`INCR`)。
    
- **权衡**: 存储对象（结构化数据）时，需要多个 key，逻辑分散且网络开销大。
    

### 1.2.2 Hash (哈希)

- **特点**: 在一个 key 中存储对象的多个字段和值（field-value 对）。
    
- **场景**: 缓存对象信息，如用户信息、商品属性。
    
- **优势**: 逻辑内聚，网络开销小，内存占用更优（底层使用 ziplist）。
    
- **权衡**: 无法为 Hash 内的单个字段设置过期时间。
    

### 1.2.3 List (列表)

- **特点**: 有序（按插入顺序）、元素可重复的字符串序列。两端操作（Push/Pop）时间复杂度为 O(1)。
    
- **场景**: 消息队列、任务栈、最新动态列表（朋友圈 Feed）。
    
- **核心命令**: `LPUSH`/`RPUSH`, `LPOP`/`RPOP`, `LRANGE`。
    

### 1.2.4 Set (集合)

- **特点**: 无序、元素唯一的字符串集合。
    
- **场景**: 全局去重、标签系统、通过集合运算实现共同好友/兴趣推荐。
    
- **优势**: 支持强大的服务器端集合运算（交集 `SINTER`、并集 `SUNION`、差集 `SDIFF`）。
    

### 1.2.5 Sorted Set (ZSET, 有序集合)

- **特点**: 元素唯一，每个元素都关联一个分数（score），并按分数自动排序。
    
- **底层实现**: 哈希表（保证唯一性，O(1)查成员） + 跳表（保证有序性，O(logN)范围查询）。
    
- **场景**: 排行榜、优先级队列、带权重的范围查询。
    
- **核心命令**: `ZADD`, `ZREVRANGE`, `ZRANK`, `ZPOPMAX`。
    

## 1.3 三、持久化机制

### 1.3.1 RDB (快照)

- **原理**: 按预设策略，将某一时间点的内存数据完整地“拍一张照片”，保存到二进制文件中。
    
- **优点**: 文件紧凑，非常适合用于备份和灾难恢复，恢复速度快。
    
- **缺点**: 两次快照之间的数据存在丢失风险，无法做到实时持久化。
    

### 1.3.2 AOF (追加文件)

- **原理**: 将接收到的每一个写命令，像记流水账一样追加到文件末尾。
    
- **优点**: 数据持久性更高，在 `everysec` 策略下，最多只丢失 1 秒的数据。
    
- **缺点**: 文件体积可能过大，恢复速度相对较慢。
    

### 1.3.3 AOF 重写 & 混合持久化

- **原理**:
    
    - **重写**: 将内存数据反向生成最简的命令集，给 AOF 文件“瘦身”。
        
    - **混合持久化**: AOF 文件由 `RDB 快照部分` + `AOF 增量日志部分` 组成。
        
- **优点**: 综合了 RDB 恢复快和 AOF 数据安全性高的优点，是目前推荐的方案。
    
- **关键点**: 重写由后台子进程完成，使用“AOF 重写缓冲区”保证重写期间新数据不丢失。
    

## 1.4 四、内存管理

### 1.4.1 过期策略

- **机制**: **惰性删除**（访问时检查） + **定期删除**（随机抽查）相结合。
    
- **目的**: 在 CPU 和内存开销之间取得平衡。
    
- **漏洞**: 可能存在大量过期键未被及时删除，最终耗尽内存。
    

### 1.4.2 内存淘汰策略

- **目的**: 当内存达到上限时，决定“扔掉”哪些数据来保护 Redis 不会崩溃。
    
- **核心算法**:
    
    - **LRU (最近最久未使用)**: 淘汰最长时间没有被访问的数据。
        
    - **LFU (最近最少使用)**: 淘汰一段时间内，被访问次数最少的数据。
        
- **关键点**: 需根据业务数据的访问模式，谨慎选择合适的策略（如 `volatile-lru`, `allkeys-lfu`），以避免误删重要数据。
    

## 1.5 🧭 学习状态与下一步 (Learning Status & Next Steps)

- **已完成**:
    
    - [✓] 高性能探源
        
    - [✓] 核心数据结构
        
    - [✓] 持久化机制
        
    - [✓] 内存管理
        
- **当前进度**: 我们已经完成了 Redis 核心内部机制的学习。
    
- **下一步建议**: 逻辑上的下一个学习单元是 **缓存应用难题**。建议从 `[!高频考点] 缓存击穿` 开始。
# 1 数据库三大范式 ⭐⭐

<div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">
  范式是数据库设计时需要遵循的一系列规范和准则，核心目的是为了减少表中的数据冗余，并确保数据的一致性和完整性
</div>
1. 第一范式：要求数据库中的每一项都是不可分割的原子项。
2. 第二范式：非主键属性必须全部依赖与主键 ，不能部分依赖。
3. 第三范式：任何非主键属性不依赖于其他非主键属性。==消除传递依赖==

	- 当然也不是必须全部符合，可以适当增加冗余项，减少联表查询。但是此时会增加数据维护以及数据不一致的风险。
	- 比如，文章表中有一列是作者昵称，这样确实可以减少联表查询，但是如果一个用户改变了他的昵称，就需要修改很多列。

# 2 CHAR和VARCHAR有什么区别 ⭐⭐
1. 是什么&核心区别
	CHAR和VARCHAR都是存储字符串的数据类型，最核心的在于存储方式不同。简单来说，CHAR是固定长度的，VARCHAR是可变长度的。
2. 细节对比
	1. CHAR(n)：定义多长，实际存储就是多长，即使传入的数据不够长，也会自动填补。==优<mark class="hltr-pink"></mark>点==是处理长度固定的数据时，可以节省时间，因为不需要计算数据长度。==缺点==是如果数据长度变化大，可能会造成空间浪费。
	2. VARCHAR(n)：n代表最大长度，实际存储会根据数据真是长度动态改变的，外加1~2个字节记录长度信息。==优<mark class="hltr-red"></mark>点==是节省存储空间，适合存储长度不一的数据。==缺点==是处理数据时会有额外性能开销。
3. 实际使用的时候遵循以下原则：
	- 选CHAR：数据长度不变，如性别、MD5加密的密码、手机验证码等
	- 选VARCAHR：数据长度会发生变化，无法预估的时候，比如文章标题等

# 3 SQL语句执行顺序 ⭐⭐
<div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">
  SQL语句实际编写顺序以及内部执行顺序是不一样的
</div>
```sql
--编写顺序
select -> from -> where -> group by -> having -> order by -> limit
--执行顺序
from -> where -> group by -> having -> select -> order by -> limit
```

# 4 SQL语句的执行过程 ⭐⭐
1. 连接器：通过这个来验证登录mysql时的账号密码，决定能否登录。
2. 分析器
	1. 词法分析：查看一个个的单词是否拼写正确。
	2. 语法分析：查看执行语句的语法是否正确。
3. 优化器：决定按照何种顺序执行代码较快。
4. 执行器：根据执行顺序将代码执行。
5. 存储引擎：负责存储和提取数据。
---
1. 连接器：首先，客户端通过连接器连接到Mysql服务器。连接器负责验证用户名和密码，并在成功后授予用户相应权限。
2. 查询缓存：在早期（8.0）版本之前，Mysql会查询缓存，如果能找到完全相同的Sql语句及其结果，就会直接返回，跳过后续步骤。但据了解，由于对频繁更新的表维护成本高且命中率低，在8.0版本已经被移除了。
3. 分析器：如果缓存不命中，语句会交给分析器，进行词法分析（关键字拼写）和语法分析（检查Sql结构是否合规），最终生成一个“语法树”。
4. 优化器：接下来，优化器根据语法树，生成它认为最高效的执行计划，比如在一张表有多个索引的时候，会计算成本，决定使用哪个索引；多表JOIN时，决定连接顺序。
5. 执行器：执行器根据优化器给出的执行计划执行操作。它会先检查用户是否有操作这张表的权限，然后调用==存储引擎==提供的接口，去完成数据的读取和返回。


# 5 SQL存储引擎 ⭐⭐⭐
- 当前MYSQL支持多种存储引擎以适应不同任务场景，这得益于其可插拔的存储引擎架构。其中最常用的主要有InnoDB、MylSAM、Memory这几种，目前MySQL默认的是InnoDB
	- InnoDB
		- 核心特性：支持事务、==行级锁==、外键
		- 优点：数据一致性、并发性好、支持崩溃修复
		- 场景：适合在线交易、金融等对数据安全要求高的系统
	- MyISAM
		- 核心特性：不支持事务、不支持外键、使用全表锁（数据存硬盘）
		- 优点：结构简单，在无并发冲突时读写速度快
		- 场景：适合对事务要求不高、并发量不大的系统（日志、报表）
	- Memory
		- 核心特性：数据存在内存中、全表锁、默认哈希索引
		- 优点：读写速度快
		- 场景：服务重启数据会丢失，适合临时表或缓存

# 6 SQL存储引擎对比 ⭐⭐⭐
- 核心对比（InnoDB VS MylSAM）
	1. 事务支持：InnoDB支持事务，符合ACID特性，适合需要高数据一致性的场景，比如金融转账。而MylSAM不支持事务。
	2. 锁机制：InnoDB支持行级锁，锁的粒度更小，大大降低了锁冲突的概率，因此并发性能非常出色。MylSAM只支持全表锁，当有写操作的时候会锁住整张表，并发性能差。
	3. 外键约束：InnoDB支持外键，有助于在数据库层面维护数据引用的完整性。MylSAM则不支持
	4. 崩溃恢复：InnoDB通过其==redo log==机制，支持数据库异常崩溃后的安全恢复，数据安全性很高。而MylSAM不支持崩溃恢复，宕机后数据损坏的风险更高。
	5. MVCC：InnoDB支持多版本并发控制，而MylSAM不支持。这也是InnoDB能够实现高并发读写的重要原因之一。

# 7 MYSQL索引 ⭐⭐⭐
- 逻辑维度
	- 基础索引
		- 主键索引：唯一且非空，每张表仅一个。
		- 唯一索引：唯一但可为空，每表可多个。
		- 常规索引：无约束，仅为加速查询。
	- 特殊索引：
		- 联合索引：多==列==组合的索引。
		- 前缀索引：索引长字符串的前N个字符，节省空间。
		- 全文索引：用于在文本中进行关键词搜索。数据库的内置搜索引擎，快速在大段文本中找出包含目标关键词的记录。
- 物理维度：
	- 聚集索引：索引的B+树叶子节点。叶子节点存储==完整行数据==，通常是主键。类比：字典的正文。
	- 二级索引：叶子节点存储主键值，查询时需要“回表”才能获取完整数据。类比：字典的部首/拼音检字表。

# 8 为什么InnoDB存储引擎选择使用B+树索引结构⭐⭐⭐
- B+树有很多优点来使得InnoDB将其作为索引结构，根本原因是B+树的设计可以使得其能够最大限度减少磁盘IO，并且高效支持数据库中最常见的单点查询和范围查询，下面列举其与几种常见方案来理解：
	1. vs 二叉树：因为二叉树的结构使得其在存储相同数量数据的时候树更深，就会需要更多的磁盘IO，所以使用B+树。
	2. vs 哈希索引：哈希索引不支持范围查询和==排序==，虽然等值查询很快，而B+树支持。
	3. vs B树：
		1. B树的非叶子节点也会存储数据，相比于B+树，每个节点存储的索引更少。
		2. B+树所有叶子节点都通过一个双向链表连接，使得其在执行范围查询的时候，可以只在叶子节点层进行水平遍历。

# 9 什么是覆盖索引/什么是回表⭐⭐⭐
- 覆盖索引和回表都是在InnoDB引擎中，因其独特的“聚集索引+二级索引”结构而产生的两种查询现象：
	1. 如果查询的列没有超出这张表的==二级索引+主键==这个范围，那就是<b style = "font-size:30px;">覆盖索引</b>。
	2. 如果超出了，那就需要根据所得的目标行的主键值“回表”去查询整行数据。

# 10 索引的使用原则/索引失效场景⭐⭐⭐
- 对于索引失效，我的理解是，==此时不代表SQL语句会报错，而是代表MySQL优化器会因为某些原因，放弃使用索引，导致查询语句退化成效率低下的全表查询==。这通常是因为我们的查询写法，让索引“失效”：
	1. 违反最左前缀匹配原则：就是说使用==联合索引==的时候，如果一个联合索引包含多个索引时，不给出最左边的索引而给出后面的，或者给的索引中间跳了，有一个索引没给。
	2. 对索引列进行计算：使用索引查询时使用的值是计算后的值。因为B+树中保存的是原始的值。
	3. Like通配符在头部：使用LIke通配符时，在开头使用%通配符。
	4. OR条件使用不当：如果OR前后一个是索引列一个不是，导致索引失效。

# 11 创建联合索引原则⭐⭐⭐
- 在创建联合索引时，为了加快查询速度，因此需要使得索引可用且高效，因此需要遵循下面两个原则：
	1. 最左前缀匹配原则：如果一个最常使用的查询场景并不需要最左边的那个，就会导致索引失效。
	2. 区分度高在左：创建多个联合索引时，因为查询时会先查询最左边的，因此最好把区分度高的索引放在左边，这样经过第一轮查询后剩下的行数更少，会更高效。

# 12 什么情况不走联合索引⭐⭐⭐
- 假设有一个联合索引（a,b,c）
	1. 完美使用：a / (a,b) / (a,b,c)  只要不跳并且包含最左边的，就可以完美使用，与书写顺序无关，优化器会自动优化。
	2. 完全不能使用：不包含a 
	3. 部分能使用：（a,c） 跳过中间的其中一个

# 13 索引的优缺点⭐⭐⭐
- 优点：
	1. 加快查询速度：使用索引，可以通过把无序的数据变成有序的B+树结构，把以前需要查全表的O(n)操作，降低到log(n)，极大地降低了查询耗时。
- 缺点：
	1. 写操作费时：在对表中的数据进行增加、删除和修改的时候，为了维护其有序性，就需要去维护这个索引，从而带来额外的性能开销。
	2. 创建和维护耗时：随着数据量的加大，对索引的建立和维护就更需要时间。
	3. 占用物理空间：索引本身是一个B+树，需要存储在磁盘上，占用存储空间。

# 14 索引建立原则⭐⭐⭐
- ==创建索引的时候，核心思想是在“查询性能”和“维护成本”之间找到一个最佳平衡点，遵循以下原则==：
1. 什么时候创建索引：
	- 当一个数据量很大的表，每次查询都很耗时，并且查询操作很频繁，但是写操作不是很频繁的时候，为最常使用的列创建索引。并且优先考虑那些出现在`WHERE`、`ORDER BY`、`GROUP BY`后面的列。
2. 怎么创建索引：
	1. 最好创建联合索引，这样的话会更好覆盖索引条件，避免回表。
	2. 对字段长的列，使用前缀索引。
3. 索引创建多少个：
	- 并不是越多越好，多了的话，每次写操作都需要维护所有的索引，耗时。

# 15 常见sql优化手段⭐⭐⭐
1. 不使用select * ：因为这样很难覆盖索引，增加回表性能开销，且可以减少服务器之间数据传输，减少服务器压力。
2. 使用自增列作为主键：
	- InnoDB使用的是按照主键顺序存储。
	- 插入手段：
		- 顺序插入：此时直接在后面追加页就行。
		- 乱序插入：如果插入的数据在已有的两顺序之间，此时就可能触发页分裂。
	- 页分裂后果：InnoDB需要新建一个页，把之前的数据大部分转移到这个新页中，会触发大量磁盘IO，大大降低插入性能。
3. 避免使用 != / <> /  is null：
	- 此时数据库优化器可能会放弃索引从而采用全表查询
	- 优化：为数据库字段添加not null约束，并且为此列无值的列创建一个默认值，作为null，之后就可以使用等值查询了。
4. 尽量使用count(\*)   因为InnoDB引擎对此做了专门的优化   优化器会自己去找占用最少的二级索引  
5. 在多表查询的时候尽量使用JOIN查询，因为InnoDB引擎对此进行了极大的优化。
6. 
- ---
- 在进行数据库优化时，主要可以分为以下三个层面，查询层面、设计层面以及语句编写层面：
	- 查询：
		1. 不使用select*   
		2. 使用JOIN代替~~联表~~<b style = "font-size:30px;"> 子查询</b>
	- 设计：
		1. 自增列做主键
		2. 为经常用到的列创建索引
	- 语句编写：
		1. 避免使用`!=` 
		2. `<>` 
		3. `is null`
		4. LIKE “%字段”通配符以%开头

# 16 SQL优化详解⭐⭐
- 插入优化：
	- 批量提交插入事件，即在一个insert语句中插入多行数据
	- 手动提交事务，将多个插入操作打包成一个事务一起提交，减少`redo log`（刷盘，也就是内存中的数据写入外存持久存储）次数
- 主键优化：
	- 主键使用顺序插入
	- 尽量降低主键长度
	- 尽量不要使用自然主键，使用自增主键
	- 业务操作时，避免对主键的修改
- ORDER BY：
	- 核心模式：
		- use filesort：低效，直接把所有符合条件的列全部读入内存之后在排序缓冲区中再排序输出
		- use index：高效，不需额外排序，直接输出
	- 优化规则：
		- 尽量使用覆盖索引，跳过的话会导致退化成为use filesort，索引时还可以部分覆盖，但是此时会直接不可用
		- 多字段时遵循最左前缀索引
		- 不可避免filesort的话，可适当增大排序缓冲区大小，`sort_buffer_size`（默认256K）
- GROUP BY：
	- 核心模式：
		- use temporary
		- use index
	- 规则同上
- limit优化：
	1. 建立排序索引
	2. 使用子查询分页，利用“覆盖索引”避免回表
	   `select * from blog inner join (select id from blog order by create_time desc limit 2000000, 10)`
- 几种COUNT（）对比：
	- count(\*)：直接对所有行数进行累加，不读取任何数据。
	- count(1)：同上
	- count(字段)：统计该字段非空的行数，最终结果可能与总行数不同，若该字段为空则不会计数。
	- count(主键)：需读取主键值，开销略大于count(\*)。
- update的优化：
	- 一个update语句中，如果where后跟的字段没有索引的话，InnoDB就会对这个语句加表锁，此时，如果有另外一个更新事务也要更新这张表中的一个字段，就会被阻塞。
	- 因此如果想要发挥出作用，就需要对where后的索引添加索引，此时执行这个语句就会对这一行数据添加行锁，此时对其他的行进行操作就可以正常执行。
- where优化：
	- 避免使用 != / <> / IS NULL 等操作符，此时可能会放弃索引而使用全表扫描。

# 17 什么时候不要用索引⭐⭐⭐
1. 一张表的读操作少，写操作多
2. 索引区分度低
3. ==表记录太少==

# 18 索引下推⭐⭐
- 在使用联合索引的时候根据两者同时查找符合的列，回表时减少比对的列

# 19 怎么找到慢sql? 可以从哪些角度优化？⭐⭐⭐
1. 先查看当前数据库是否有慢查询日志
2. 有的话就查看哪些语句速度慢，没有的话就创建慢查询日志
3. 使用explain语句查看慢查询语句情况，重点关注一下几列：
	1. type：避免出现ALL（全表扫描）
	2. key：查看是否使用了索引
	3. extra：查看是否存在user filesort  或者use temporary高成本操作
4. 优化：
	1. 索引优化
	2. sql语句改写
	3. 表结构和业务优化


# 20 什么是慢查询日志（slow query log）？⭐⭐⭐
- 记录执行时间超过Long_query_time的所有查询语句
# 21 解释一下执行计划？⭐⭐⭐

# 22 发现查询速度很慢，怎么解决？⭐⭐⭐

# 23 解释一下发现执行的索引不正确的话，怎么办？⭐⭐⭐
- 使用force index  强制走索引
# 24 什么是数据库事务/事务的四大特性？⭐⭐⭐
- 事务是数据库中一系列操作的集合，内部的操作要么全部成功要么全部失败。
1. 一致性：事务执行前后只能从一个一致状态转换成为另外一个一致状态。比如转账前后，两个账户的总金额不变。
2. 隔离性：不同事务之间是隔离的，也就是说一个事务查询一个字段值的时候，就算另外有一个事务对这个字段进行改变，这个查询的事务查询值也一样。==底层通过MVCC和锁机制实现的。==
3. 原子性：每个事务内部的操作要么全实现，要么全不实现。银行转账，一个扣钱一个收款，这两个动作必须捆绑在一起。通过undo log实现的。
4. 持久性：事务一旦提交就会在磁盘上永久保存。通过redo log实现的。

# 25 隔离性产生的问题？⭐⭐⭐

| 问题类型  | 核心区别     | 另一个事务的操作      | 另一个事务的状态                                        |
| ----- | -------- | ------------- | ----------------------------------------------- |
| 脏读    | 读到“脏”数据  | UPDATE        | <mark style="background: #FFB8EBA6;">未提交</mark> |
| 不可重复读 | 同一行数据被修改 | UPDATE/DELETE | <mark style="background: #ADCCFFA6;">已提交</mark> |
| 幻读    | 查询的行数变化  | INSERT/DELETE | <mark style="background: #ADCCFFA6;">已提交</mark> |

# 26 事务的隔离级别？⭐⭐⭐
- 数据库隔离会产生一系列问题，其中有三种：脏读、不可重复读和幻读
	1. 读未提交：这个可以读未提交的内容，在COMMIT之前，连<mark style="background: #FFB8EBA6;">脏读</mark>都解决不了。
	2. 读已提交：此时要求只能读已提交的内容，这就解决了<mark style="background: #FFB8EBA6;">脏读</mark>。
	3. 可重复读：从名字我们就可看出，这种隔离级别解决了<mark style="background: #FFB8EBA6;">不可重复读</mark>，因为此时在执行查询语句时，会通过MVCC给整个数据库拍下一张“全景图”，从而保证下次查询时查看的是这个照片，就解决了<mark style="background: #FFB8EBA6;">可重复读</mark>。而且此时，也可以解决幻读的普通读操作，但是像UPDATE和DELETE这种就不能解决了，此时就需要下一个更严格的隔离
	4. 串行化：强制要求数据库的事务只能一个个执行，在上一个提交之前下一个事务不能开始。<mark style="background: #FFB8EBA6;">这就</mark>完美的解决了<mark style="background: #FFB8EBA6;">幻读</mark>，但是也因此会让数据库浪费一些性能。

# 27 MySQL的隔离级别怎么实现的？⭐⭐
<div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">
  Mysql的隔离是通过MVCC机制和锁机制实现的，其中读未提交、读已提交是通过MVCC，可重复读是通过MVCC加锁实现的，可串行化是全部通过锁实现的。
</div>

# 28 单条更新语句是原子性的吗？⭐⭐

# 29 什么是MVCC？⭐⭐
- Multiple-Version Concurrency Control

# 30 MVCC 可以为数据库解决什么问题？⭐⭐

# 31 MVCC的实现原理？⭐⭐
- MVCC全名是多版本并发控制，<mark style="background: #FF5582A6;">是一种并发控制的方法</mark>，主要保证在数据隔离前提下，实现读写操作不冲突，从而提升并发性能。核心工作原理可以概括为：<mark style="background: #BBFABBA6;">快照读</mark>、<mark style="background: #BBFABBA6;">多版本</mark>
	1. 在一个select事务执行时，数据库会先创建一个Readview，也就是当前数据库的一个快照，记录当前数据库的状态，后续事务内的<mark style="background: #FF5582A6;">所有读操作</mark>都是根据这个快照来的，也就因此保证了“可重复读”。而数据库中的之所以可以提供这个，就是通过数据行上的隐藏字段：`trx_id `，事务会拿着自己的Readview去版本链上找到第一个可见的版本并返回。

# 32 ReadView是什么？⭐⭐

# 33 当前读与快照读？⭐⭐

|     | 是什么                                    | 怎么读        | 加锁  |
| --- | -------------------------------------- | ---------- | --- |
| 快照读 | select                                 | 根据Readview | 不加  |
| 当前读 | update/delete/insert/select for update | 停止别的修改操作，  | 加锁  |


# 34 MVCC是怎么实现不可重复读的？⭐⭐
- 在不同隔离级别下MVCC生成的Readview时间不一样
	- 在“读已提交”下，每一次select语句执行时都会创建一个Readview，因此会出现前后矛盾的情况
	- 在“可重复读”下，一个事务只会在第一次执行时创建一个Readview，后续的读操作都是按照这个来的

# 35 MVCC是怎么防止幻读的？⭐⭐
- 对于“快照读”：只在事务的第一次查询语句执行时生成一次Readview，后面的读操作是根据这个来的，因此也就避免了幻读。
- 对于“当前读”：使用<mark style="background: #FF5582A6;">“临键锁”</mark>，在查询语句生成时，不仅会锁住当前语句，还会锁住符合当前查询语句的所有间隙来防止别的语句修改。

# 36 锁的分类？⭐⭐
- 全局锁：对整个数据库实例加锁，~~除了当前事务任何事务都不能操作这个数据库。~~<mark style="background: #FF5582A6;">别的读操作可以，但是写操作不行。</mark>
- 表级锁：对操作的表加锁，同时不允许别人写操作。
- 元数据锁：有读锁和写锁，增删改查（DML）时加读锁，修改表结构（DDL）加写锁。
- 行级锁：InnoDB引擎中粒度最大的锁，只锁住当前操作的这一行，

# 37 共享锁和排他锁？⭐⭐
- 共享锁（又称读锁）：加锁期间别的事务可以读但是不能写
- 排他锁（写锁）：只允许加锁的事务操作

# 38 表级锁和行级锁的区别？⭐⭐
- 表级锁：锁定粒度大，为整张表；加锁开销小；并发性能差。
- 行级锁：锁定粒度小，只是操作的那一行；加锁开销大；并发性能好。

# 39 InnoDB有哪几类行锁？⭐⭐
- 记录锁：锁住当前操作的这一行，<mark style="background: #FFB8EBA6;">防止其他事务对用一条记录进行修改，实现单行数据的隔离。</mark>
- 间隙锁：锁住当前操作的间隙；<mark style="background: #FFB8EBA6;">防止其他事务在间隙中插入新纪录，从而解决<mark style="background: #FF5582A6;">幻读</mark>问题。</mark>。
- 临键锁：相当于记录锁+间隙锁，锁住当前操作的范围中第一条记录（加上记录锁）和之前的那一条记录之间的间隙，组成临键锁。

# 40 数据库的表锁和行锁有什么作用？⭐⭐


|     | 作用        | 使用场景                 |
| --- | --------- | -------------------- |
| 表锁  | 锁住整张表     | 数据库备份等并发要求不高         |
| 行锁  | 只锁住操作的那一行 | 并发要求高的场景、在线交易、更新用户信息 |

# 41 MySQL事务的更新语句同时更新同一条数据，会发生什么情况？⭐⭐
- update语句属于“当前读”，在执行语句时会为当前行加上一个行级排他锁，因此当两个更新语句同时更新一条数据时，先到的语句会为当前行上锁，后到的只能等前者撤销锁之后再执行。

# 42 避免更新修改语句处理同一张不同范围的数据，一个<5，一个>10，会阻塞吗？⭐⭐
- 两个更新修改语句同时处理一张不同范围的数据时，是否会阻塞需要看情况：
	- 若是where后的语句有索引：此时就不会阻塞
	- where后语句没建立索引，就会阻塞，因为此时相当于全表扫描

# 43 三大日志？⭐⭐⭐
- undo log：记录事务操作数据的旧记录，为了数据库的回滚，保证了数据库的原子性。<mark style="background: #FFB8EBA6;">实现MVCC。</mark>
- redo log：记录事务操作数据的新的记录，若是数据库突然宕机可以使用这个日志来修改数据。保证了持久性。（物理上的修改，我们在读取数据的时候是从磁盘中将所需数据读取到内存，redo log的作用是将对这个数据页的修改保存，当数据库宕机恢复后就可以再次修改磁盘中的数据了。）
- binlog：整个数据库的录像，为了数据库的复制和备份

# 44 为什么提交事务后不直接将Buffer Pool的数据同步到磁盘上？⭐⭐

# 45 binlog 和 redolog 有什么区别？⭐⭐

|          | 作用层面                     | 干什么                    | 内容格式          | 写入方式 | 用途        |
| -------- | ------------------------ | ---------------------- | ------------- | ---- | --------- |
| binlog   | mysql server层面，所有数据库引擎都有 | 记录数据库的所有修改记录           | 逻辑日志，记录DDL和DM | 追加写  | 数据库的复制和备份 |
| redo log | 只在InnoDB上有               | 记录数据修改之后的新值，用于数据库的宕机修复 | 物理日志          | 循环写  | 数据库宕机恢复   |

# 46 为什么需要重做日志？⭐⭐⭐
1. 保证持久性：事务提交时，数据此时可能就在内存中，此时宕机的话会让数据丢失，就无法保证持久性了。而引入redolog后可以将需要修改的数据以及怎么修改存下来。
2. 提升写磁盘速度：直接写磁盘是随机写，速度慢，而先写入redolog后再写入磁盘就是顺序写，大大提升写入速度。

# 47 两阶段提交是什么？⭐⭐
- 两阶段提交解决了redolog和binlog记录不一致导致主从数据库数据不一致的问题。
- 实现方式：
	- 在一个事务提交时，将其先写入redolog，并标记为prepare状态，然后将其写入binlog，再将其提交并在redolog中状态修改为commit。
- 修复逻辑：
	- redolog中为prepare，binlog中无对应数据记录：事务回滚
	- redolog中为prepare，binlog中有对应数据记录：提交事务

# 48 撤消日志？⭐⭐⭐
- undolog是数据库中的回滚日志，记录一个修改之前的数据库状态，保证了数据库的原子性。并且通过这个记录修改之前的数据库状态为数据库中的MVCC机制提供了支持。

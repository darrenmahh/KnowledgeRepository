# 1 Java基础
## 1.1 说一下Java的特点
- 面向对象、跨平台、健壮（自动回收空间、强类型检查、异常处理）、多线程、编译与解释共存（编译成字节码+JVM解释运行）、简单（相比C++）

## 1.2 Java 的优势和劣势是什么？
- 优势：上面所说的特点
- 劣势：
	1. 语法冗长，有较多模板代码
	2. 极端性能和低延迟上，GC停顿和JVM会成为瓶颈
	3. 启动慢，内存消耗大，且内存占用通常高于C/C++
	4. 部署需要JRE环境，客户端软件的分发不如本地编译的程序方便

## 1.3 Java为什么是跨平台的？

## 1.4 JVM、JDK、JRE三者关系？

## 1.5 为什么Java解释和编译都有？
1. 跨平台：需要编译，javac成为字节码之后面向jvm
2. 快启动：需要解释
3. 高性能：需要即时编译（JIT），将热点代码一次性编译成为高效的本地机器码并缓存，从而使得性能接近原生C++

## 1.6 jvm是什么
是一个拥有双重身份的概念
1. 从规范层面：详细定义了Java字节码文件应该如何被执行，包括内存的划分以及指令集等
2. 从实现层面：是一个具体的软件程序，是这套规范的一种实现
它的核心工作是加载并执行.class字节码文件，通过解释执行以及即时编译相结合的方式将通用的字节码翻译成为特定平台的机器码。
最终，通过充当Java代码和具体操作系统之间的“虚拟计算机”和“翻译官”，使得Java能实现跨平台这一重要特性。

## 1.7 编译型语言和解释型语言的区别？
- **执行流程**：编译型是“先完整翻译，再统一执行”，生成的是目标平台的机器码；解释型是“边翻译，边执行”，直接操作源代码。
    
- **运行速度**：编译型因为免去了运行时的翻译开销，所以速度更快；解释型则因为需要实时翻译而较慢。
    
- **跨平台性**：编译型需要为不同平台生成不同的可执行文件，不跨平台；解释型则凭借解释器的存在，让同一份源代码可以通行于所有平台。

## 1.8 Python和Java区别是什么？
1. 静动态类型语言
2. 性能差异
3. 应用领域
4. 语法简单与否

## 1.9 八种基本的数据类型

## 1.10 int和long是多少位，多少字节的？

## 1.11 long和int可以互转吗 ？
1. int转long：可以，会发生自动类型转换，无需任何特殊语法
2. long转int：可以，有数据溢出的风险，必须使用（int）进行强制类型转换（显式），明确告诉编译器我同意这个风险

## 1.12 数据类型转换方式你知道哪些？
1. 基本数据类型转字符串：String str = String.valueOf(“123”) 或者String str = "" + "123";

> [!warning] 这里使用数据本身，不需要加引号
> String str = String.valueOf(==“123”==) 或者String str = "" + "123";
> 这里是   String str = String.valueOf(==123==)   和   String str = "" + 123

2. 字符串转基本类型：使用对应类型的类的方法Integer.parseInt() Long.parseLong() Double.parseDouble
但是需要字符串格式正确
3. 基本数据之间：
- **自动类型转换（隐式转换）**：当把一个表示范围小的数据类型赋值给一个范围大的数据类型时，编译器会自动完成转换。例如：`long l = 100;` (int到long) 或 `double d = 200L;` (long到double)。
- **强制类型转换（显式转换）**：当需要把一个范围大的数据类型赋值给范围小的数据类型时，必须使用 `(目标类型)` 语法进行强制转换，并且需要自己承担可能的数据溢出或精度丢失风险。例如：`int i = (int) 123L;`。

## 1.13 类型互转会出现什么问题吗？
1. 数据溢出：大的向小的转换
2. 运行时异常：字符串向基本数据类型转换时，类型对不上
3. 精度丢失：double向float转换时  && 非常大的整数  long转int

## 1.14 为什么用bigDecimal 不用double ？
1. 根本原理不同
- double：基于二进制浮点数，导致无法精确表示许多小数，如0.1，运算过程中，这种错误会不断累积，最终结果与预期不符。
- BigDecimal：存储一个非常大的整数和小数点位置，所有运算都基于这个整数，模拟人工笔算，结果完全正确。
1. 应用场景不同
- double：适用于科学计算和工程计算等性能要求高，但是精度没有那么极致
- BigDecimal：适用于精度要求极高的场景，金融、电商、会计等
1. 使用方式不同
- double：基本数据类型，可以直接加减乘除
- BigDecimal：是一个类，必读调用其提供的方法：add subtract multiply divide

## 1.15 装箱和拆箱是什么？
- 装箱：基本类型->类
- 拆箱：类->基本类型

## 1.16 Java为什么要有Integer？
1. 万物皆为对象
2. 适应泛型
3. 使用方便，Integer提供常用的方法

## 1.17 Integer相比int有什么优点？
1. 可以表示为null，int默认为0；并且可以区分”值为0“和”没有值“
2. 可以作为泛型参数，因为是个类
3. 提供丰富工具方法和常量

## 1.18 那为什么还要保留int类型？
1. 内存占用更少，int固定占据4字节，而一个Integer对象出了一个int值之外，还需要额外的空间来存储对象头等元数据，总内存占用远大于int，需要存储大量数据的情况下，使用int能极大地节省内存资源。
2. 性能更高：int作为基本类型，通常直接存储在==栈内存==中，cpu可以直接快速访问。而Integer是对象，其实例通常存储在==堆内存==中，访问时需要先通过栈上的引用找到堆中的对象，多了一层间接访问的开销，并且Integer还会带来额外的自动装箱/拆箱的性能成本。
总得来说，int代表效率，Integer代表面向对象的灵活性和功能性。

## 1.19 说一下 integer的缓存
- 目的：复用对象，因为程序中一些小的整数值会被频繁使用，避免每次使用的时候不造成不必要的内存开销和GC压力，从而提升性能。
- 缓存范围：-128-127
- 触发条件：
	- 会使用缓存：自动装箱，如Integer a = 10;  或者调用Integer.valueOf()方法，如果在范围内，就会触发缓存。
	- 不会使用缓存：显式使用new Integer来创建对象

## 1.20 怎么理解面向对象？简单说说封装继承多态
- 面向对象就是一种编程思想，将程序看成无数个相互独立又彼此协作的对象集合。把现实世界的事物抽象成为程序中的对象，并定义其属性和行为，来模拟显式世界的运作，程序不再是一系列执行步骤，而是设计不同对象之间如何收发消息、协同工作来完成任务。
- 三大基本特征
	1. 封装：将对象的属性（数据）和行为（方法）打包，并尽可能隐藏内部实现细节，只对外暴露必要的、安全的接口。
	2. 继承：允许一个子类自动地拥有其父类的属性和方法，并可以在此基础上进行扩展。
	3. 多态：指同一个方法调用的时候，若是作用于不同对象，会产生不同的行为。

## 1.21 多态体现在哪几个方面？
1. 运行时多态：子类重写父类的方法，具体调用哪个是程序==运行==时决定的。基于`重写`，根据引用变量以及指向的对象类型来决定调用哪个方法，而不是根据引用变量的**声明类型**。
2. 编译时多态：程序==编译==的时候已经静态决定了。基于`重载`。

## 1.22 多态解决了什么问题？
1. 提高代码的灵活性和可扩展性。允许我们增加新的子类来实现新的功能，而无需修改依赖于父类或接口的现有代码，这使得系统能够轻松应对需求变化，遵循了“对扩展开放，对修改关闭”的设计原则。
2. 降低代码的耦合度。多态让调用者不再依赖于具体的子类实现，而是依赖于一个抽象的约定，成功将调用者和实现者解耦，使得双方可以独立进行修改和演进，只要遵守约定即可。
3. 提高代码的复用性。可将通用的属性和行为放在父类中，由子类共享，而将差异化的行为由各自的子类去实现。

## 1.23 面向对象的设计原则你知道有哪些吗
1. 单一职责原则：各司其职，例如厨房工具，一个工具干一件事。
2. 开放封闭原则：对扩展开放、对修改封闭。例如手机系统，新功能，通过下载新APP实现。
3. 里氏替换原则：所有使用父类的地方，必须能使用其子类来透明地替换，且程序行为不能出错。
4. 接口隔离原则：不应该强迫一个类去实现它用不到的方法。餐馆点菜：不给只想喝咖啡的人全部的菜单。
5. 依赖倒置原则：代码要依赖于“抽象”（接口），而不是依赖于“具体实现”（类）。例如，台灯和插座都应该遵循国标插座这个抽象标准。

## 1.24 重载与重写有什么区别？

|       | 重载                      | 重写                                   |
| ----- | ----------------------- | ------------------------------------ |
| 发生位置  | 同一个类中                   | 有继承关系的父子类                            |
| 方法签名  | 名字必须相同，参数列表不用(个数、类型、顺序) | 方法名参数列表必须全部相同                        |
| 返回值类型 | 无关                      | 相同或者是其子类                             |
| 访问修饰符 | 无关                      | 子类的不能比父类严格                           |
| 绑定时期  | 编译时绑定(静态绑定)             | 运行时绑定(动态绑定)JVM在运行的时候才根据对象的实际类型决定调用方法 |
| 核心作用  | 方标调用者，同一个方法处理不同数据       | 实现多态，让子类可以改变父类的方法                    |

## 1.25 抽象类和普通类区别？
1. 能否实例化：抽象类不能实例化，而具体类可以new直接实例化。
2. 包含的方法：抽象类可以包含抽象方法和具体方法，但是普通类只能包含普通方法。
3. 存在目的：抽象类的存在就是为了被继承，由子类来实现抽象类规定的方法，普通类的存在就是为了被实例化。

## 1.26 Java抽象类和接口的区别是什么？

|       | 抽象类                    | 接口                                  |
| ----- | ---------------------- | ----------------------------------- |
| 关键字   | abstract class         | interface                           |
| 继承/实现 | 子类使用extend继承，只能继承一个抽象类 | 实现类使用implements，可以实现多个接口            |
| 设计理念  | 是什么                    | 有什么功能                               |
| 成员变量  | 可以包含各种类型的成员变量          | 只能是public static final，只要是变量就是，不写也是 |
| 成员方法  | 可以包含抽象方法个有方法体的普通方法     | 主要包含抽象方法                            |
| 构造方法  | 有构造方法                  | 没有构造方法                              |


## 1.27 抽象类能加final修饰吗？
- 不能，因为抽象类就是为了被继承的
- final修饰类就说明这个类不能被继承

## 1.28 接口里面可以定义哪些方法？
- Java 8前只能有抽象方法；Java 8+可有`default`和`static`方法；Java 9+可有`private`方法。

## 1.29 抽象类可以被实例化吗？
- 抽象类不可以被实例化。因为它是一个不完整的类，可能会包含仅声明但未实现的抽象方法，也就是没有方法体，它的作用就是作为一个蓝图来被继承的。

## 1.30 接口可以包含构造函数吗？

> [!NOTE] 构造函数
>  实例化类的时候，new后直接调用的方法，类似于python的"__init__"

- 不可以，因为构造函数就是一个类实例化时的操作，但是接口却是不可被实例化的类

## 1.31 解释Java中的静态变量和静态方法
1. 静态变量：
	- 使用`static`关键字声明的变量。本质是一个属于类的字段或数据成员，而不属于任何一个独立对象的字段。
	- 归属于类。无论创建多少个类的实例，静态变量在内存中都只会有一个副本。
	- 生命周期和类本身相同。当类被加载到内存的时候就被分配空间，只有程序结束卸载类的时候，它才会被销毁，意味着它的生命周期贯穿整个程序运行期间。
	- 任何一个对象实例对这个变量的修改都会立刻影响到其他所有对象实例。
	- 调用方式：类名.方法名()
	- 使用场景
		1. 常量：对于所有对象来说都是不变的，如Math.PI。
		2. 计数器：统计一个类被实例化了多少次。
		3. 共享配置信息：所有类的实例都需要依赖一份共同的配置数据。
2. 静态方法：
	- `static`声明的方法，本质是一个属于类的方法或函数，执行不依赖任何对象的状态。
	- 归属于类。
	- 核心限制：
		1. 不能直接访问实例变量。因为静态方法不与任何具体对象实例绑定，所以不知道`this`是谁，实例变量是属于具体对象的，没有对象就无法访问。
		2. 不能直接调用实例方法。原理同上。
	- 可以直接访问本类的所有静态变量和静态方法。
	- 使用场景：
		1. 工具类：当一个方法的功能是纯粹的计算或操作，不依赖于对象内部的状态时，就适合做成静态方法，例如`java.lang.Math`类中的所有方法，只对自己接受的参数进行操作。
		2. 工厂方法：用于创建和返回类实例的辅助方法，可以提供比构造函数更灵活的实例化方式。例如`Integer.valueOf("123")
		3. 访问和修改静态变量：为私有的静态变量提供一个公共的getter或setter方法，是封装静态数据成员的常用手段。

## 1.32 非静态内部类和静态内部类的区别？
- 非静态内部类和静态内部类都是属于内部类，也就是写在另外一个类内部的一个类，具体有以下区别：
	1. 创建：非静态的需要先实例化外部类，再通过其来实例化非静态内部类；而静态内部类则不需要先实例化外部类，可以直接使用外部类加.来实例化。
	2. 关系：非静态的是寄生于外部类内部的类，而静态的则是独立于外部类的
	3. 访问：非静态的可以访问外部类的所有成员，而静态的只能访问外部类的静态成员

## 1.33 非静态内部类可以直接访问外部方法，编译器是怎么做到的？
- 程序员先为外部类实例化，然后在实例化内部类的时候，编译器隐式地将我们实例化的外部类内存地址传给了内部类，然后内部类在访问外部方法或成员的时候就是相当于实现了外部类.成员 才实现的非静态内部类访问的外部成员
---
- 当编译一个包含非静态内部类的Java文件时，编译器在背后做了两件关键的事情：
	1. 为非静态内部类生成一个独立的`.class`文件。
	2. 在内部类的构造方法中，**隐式地增加了一个参数**，类型是外部类的类型。同时，在内部类中也**隐式地增加了一个成员变量**来持有这个外部类实例的引用。当你通过`outerInstance.new InnerClass（）`创建内部类实例时，编译器会自动将`outerInstance`这个外部类的引用作为参数传递给内部类的构造方法，并保存在那个隐式的成员变量里。

## 1.34 Java 中 final 作用是什么？
- final是Java中的一个关键字，可以用来修饰变量、方法以及类。
	1. 修饰变量时：
		1. 修饰基本类型：说明这个变量只能被赋值一次，然后值就再也不能改变。
		2. 修饰引用类型：锁住这个变量的地址，可以修改变量内部，但是不能修改变量值。
	2. 修饰方法时：
		- 此方法不再能被重写。
	3. 修饰类的时候：
		- 此类不再能被继承或修改。

## 1.35 深拷贝和浅拷贝的区别？
- 深拷贝和浅拷贝都是Java中提供的拷贝的方法，两者有些方面实现相似，但是还是有些部分是不同的。
	- 在拷贝基础类型时：两者均是直接复制那个值，两者效果并没有任何区别。
	- 在拷贝引用类型变量时：
		- 浅拷贝：只复制引用变量本身（也就是内存地址），最终新旧两个对象的这个成员变量，指向的都是同一个下游变量。
		- 深拷贝：不仅复制引用变量，还会递归地创建那个下游对象的全新副本，最终新旧两个成员变量，指向的是两个内容相同但完全独立的下游对象。

## 1.36 实现深拷贝的三种方法是什么？
- Java中实现深拷贝有三种方法，下面我将一一介绍这三种方法及其优缺点。
1. 重写clone()方法--实现接口之后重写其clone方法
	- 优点：全部手写，代码可控可修改。
	- 缺点：容易出错且需要实现Cloneable接口。
2. 使用序列化--先实现类再序列化
	- 优点：不需要重写方法。
	- 缺点：所有相关类都需要实现Serializable接口。
3. 调用第三方库
	- 优点：一行代码就可以搞定，且实现稳定。
	- 缺点：需要预先引用相关包，增大项目体积。

## 1.37 什么是泛型？
- 泛型是一个规定目标变量存储数据时的类型检查，它有很多的好处。
	1. 类型检查：把数组存储数据类型检查提前到编译阶段，而不是之前的只有在运行时才会报错。
	2. 消除代码冗余：不需要像之前一样，取数据时还需要进行类型转换。
	3. 提高代码复用：创建类的时候可以使用T来规定类实例化的时候需要传入类型参数，使得创建一个类可以在多类型中

## 1.38 java创建对象有哪些方式？
- java中一共提供了四种创建对象的方式，分为两大类：调用构造方法和不调用构造方法
	- 调用构造方法：
		- new关键字：这个是最简单的，只需要一行代码就可以实现。
		- 反射机制：相比于使用new，这个更灵活，可以在不修改源代码之后重新编译的前提下修改调用的类，比较灵活。
	- 不调用构造方法：
		- 使用clone方法：默认是浅拷贝，但是可以重写clone实现深拷贝。
		- 反序列化：通过读取对象的二进制字节流，并从中还原出对象。

## 1.39 New出的对象什么时候回收？
- 在Java中，一个对象在使用New方法创建之后，系统会先通过Gc Roots来判断这个对象是否可达，在这个对象变成不可达之后，系统会，系统会对其进行检查，看该对象是否需要执行`finalize`方法。若是改对象没有重写该方法，系统就会直接回收该对象；或者，需要执行该方法，系统就会将该对象放在F-queue中，该对象可在此方法中重写代码，可以在这个方法中创建新的GC roots，此时该对象就可以复活，从而移出“不可达”队列，不然就直接回收该对象。而且，在第二次该对象变成不可达之后，系统检查时，发现该对象已经执行过来finalize方法，就不会再给其机会，会直接回收。

## 1.40 如何获取私有对象？
- 在Java中，类的private成员，如变量或者方法等，一般是不允许别的类直接访问的，但是我们可以通过反射机制来绕过这个类型审查来获取其私有成员。在这个过程中，最重要的就是要调用setAccessible方法，来告诉它我们就是要访问这个成员，并且已知其危害。

## 1.41 什么是反射？
- 反射是一种运行时的机制，允许我们在编译时可以不依赖任何不存在的类，非常灵活。
- 主要功能是可以通过反射来动态创建对象以及使用类内的成员和方法，哪怕是private也可以通过setAccessible方法来绕过类型审查。
- 优点是灵活，而且是在运行是才使用的机制；缺点是对性能开销要求高，因为涉及动态创建，以及破坏类的封装性，以及代码可读性差。

## 1.42 反射在你平时写代码或者框架中的应用场景有哪些?
- 反射是一种运行时的机制，这个机制给我们提供了很多方便，下面我介绍一下这个机制的常见使用方法：
	1. Spring基石：Spring框架就是使用的这个机制来动态加载bean对象。
	2. 处理注解：使用反射机制来让类在运行时动态查找注解的实现。
	3. 动态加载JDBC驱动：使代码与驱动引擎解耦，可以动态改变引擎。

## 1.43 能讲一讲Java注解的原理吗？
- Java注解本质上就是一个标签，保存一些信息。为了使其可用，我们需要做两件事，第一是使用元注解`@Retension(RetentionPolicy.RUNTIME)`来使得其在程序运行时可见；第二就是需要编写一个处理这个标签的处理器，通过反射在运行时扫描、读取注解。这样才能让一个编写的注解真正可用。

## 1.44 对注解解析的底层实现了解吗？
- 编译时，~~JVM会把所有`@Retension(RetentionPolicy.RUNTIME)`的注解加载到内存中~~，javac编译器将注解信息写入存入`.class`文件的属性表中。
- 运行时，JVM加载相关类的时候，把该属性表的注解信息加载到内存，与`Class`==对象==相关联。
- 解析时，==当我们调用`getAnnotation`==，JVM会通过动态代理创建一个==实现该注解接口的代理对象==来返回，~~是注解类的实例化，通过这个来实现类的方法。
~~
## 1.45 Java注解的作用域呢？
- Java注解的作用于由元注解`@TARGET`，通过其`ElementType`值来确定的。
- TYPE：类 接口
- FIELD：成员变量
- METHOD：方法上
- CONSTRUCTOR：构造函数上
- PARAMETER：方法参数上

## 1.46 介绍一下Java异常
- 异常是Java程序的时候出现的错误，这种错误分为很多种。
- 家族体系：
	- Throwable：老祖宗。
	- ERROR：天灾，由JVM处理。
	- EXCEPTION：人祸，可以在编写代码时避开。
- 其中，EXCEPTION分为以下两种：
	- CHECKED ：这种异常必须在编写代码的时候通过~~throw~~`catch`捕捉或者通过throws关键字声明，或者throw在代码中主动、手动创建异常并抛出。
	- RENTIMEEXCEPTION：这种是修改代码避免的


## 1.47 Java异常处理有哪些？
 <div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">
  Java异常是程序运行时可能出现的错误，通过这种方式可以将其在编译时捕捉并抛出，使得程序不至于崩溃。下面是几种异常处理：
</div>
- `try catch`语句：就地处理，将可能出现的异常捕获并执行相关代码。并且当程序会有多种异常类型时，通常需要多个catch语句来执行，此时需要注意顺序，将具体的放在前面，更宽泛的放在后面，使得可以捕捉到更具体的异常。
- `finally`：善后工作，无论出现什么问题都要执行的代码。如果此时代码中有return，那这个语句将会覆盖原有的return语句。
- `throws`：在方法签名的时候使用，将责任转给调用者，告诉调用的人，也可以通过这三种方式处理。在编译时出现的错误使用这个来告诉调用者可能出现的错误。对于运行时异常，也可以通过这种方式声明，但是通常不强制，因为此时可以通过改进代码逻辑来避免。
- `throw`：在程序内部负责抛出错误的关键字，throws是在方法声明时使用的。
- `try-with-resource`：在try后跟资源调用代码，在使用完毕后就会自动关闭资源。

## 1.48 抛出异常为什么不用throws？

<div style="background: #333; color: #f5f5f5; padding: 15px; margin: 20px 0; border: 1px solid #555; border-radius: 5px;">
  抛出异常但是方法上不用使用throws声明主要有以下两种方法：
</div>
1. 这个异常是非受检异常或者是属于ERROR，此时不需要使用throws声明。
2. 这个异常在方法内部被catch捕获并就地处理了。

## 1.49 try catch中的语句运行情况

## 1.50 try{return “a”} fianlly{return “b”}这条语句返回啥
## 1.51 \== 与 equals 有什么区别？
- 这两种方法都是比较两个变量或者引用是否相等的，但是相互之间又有不同：
	- `"=="` ：
		- 当对象是基本数据类型时：直接比较两者值是否相等。
		- 引用类型：比较两者内存地址。
	- `equals`：
		- 基本实现：使用的就是"\=="的逻辑
		- 在一些类中，如String等，内部对其进行重写，比较其指向内容是否相等

## 1.52 hashcode和equals方法有什么关系？
- 两者之间有个约定：即equals方法相等的其hashcode必须相等
- 这个约定规定必须同时重写equals方法和hashcode方法
- HashSet工作原理是：先调用hashcode方法来为要存入的对象快速分区，再调用equals来进行精确比较，若是没有相同元素才能存入

## 1.53 String、StringBuffer、StringBuilder的区别和联系
- `String`：大哥，属于不变的字符串，对原字符串修改时会新创建一个字符串，因为他的不变性因此是线程安全的。在一个字符串一般不修改时可以使用。
- `StringBuilder`：在使用这个对象创建的对象发生变化的时候，并不会像`String`一样，新创建一个对象，但是是线程不安全的。在字符串需要频繁修改时使用，单线程。
- `StringBuffer`：在`StringBuilder`的基础上，加上了线程安全，可以在多线程修改时使用。

## 1.54 Java 8 你知道有什么新特性？
1. lambda表达式
	- 使用() ->{}传递函数代码
2. 流式处理Stream API
	- 在对一个对象进行一系列操作的时候，使用流处理来保存中间流水线操作，而不直接执行相应方法
3. Optional处理空指针异常
	- 可以直接调用该对象的orElse和ifPresent来执行

## 1.55 Lambda 表达式了解吗？
## 1.56 Java中stream的API介绍一下
## 1.57 Stream流的并行API是什么？
- 并行API是stream流提供的一键加速的能力，能自动将一个大型任务自动拆分成小任务分别执行
- 底层使用的是FORK/JOIN
- 只要使用parallel方法就可以直接调用
- 适合大型密集型计算

## 1.58 completableFuture怎么用的？
- 解决了前辈Future的两大痛点：
	- 调用get方法时会阻塞主进程
	- 没有回调机制
- completableFuture机制
	- 调用supplyAsync  和  
	- thenApply中间加工
	- thenAccept最后处理
	- exceptionally  异常抓手

## 1.59 Java 21 新特性知道哪些？
1. 虚拟线程：解决了之前Thread创建的线程和系统内核线程1:1的关系，之前那种会为每个==请求==创建一个线程，对应系统内核线程，会占用系统资源。现在这种虚拟线程在一个线程被阻塞时会调用别的，就是说一个现在的一个虚拟线程可以在宏观上并行做事。

## 1.60 怎么把一个对象从一个jvm转移到另一个jvm?
1. 通过网络通信，比如Socket套接字。优点是直接、实时，缺点是强耦合，双方必须同时在线。
2. 消息队列 如RabbitMQ  Kafka。优点是异步解耦、可靠性高，缺点是有一定延迟。
3. 共享存储 如Redis。优点是实现简单，侧重状态共享，缺点是可能存在并发控制问题。
4. RPC框架直接调用。可以直接调用一个类的方法

## 1.61 序列化和反序列化让你自己实现你会怎么做?
- 💡选择一个格式：
	- JSON：信息清晰可见，但冗余、低效
	- 二进制流：信息紧凑且高效，但是需依赖Scheme
- 协议设计：
	- 使用二进制流的话，双方需要一个共同的"密码本"

## 1.62 将对象转为二进制字节流具体怎么实现?
## 1.63 volatile和sychronized如何实现单例模式
- 为了兼顾性能和线程安全，我通常会使用"双重检查锁定"模式来实现单例，这个模式需要volatile和sychronized共同实现：
	- 首先将一个类的构造函数生成为private，只允许类自己调用
	- 然后使用sychronized来实现对一个操作的同步操作，同一时间只允许一个线程进入这个操作
	- 使用volatile来对一个实例操作进行禁止指令重排序，从而实现单例模式

## 1.64 代理模式和适配器模式有什么区别？
- 适配器模式：转换插头
- 代理模式：明星经纪人
## 1.65 Java怎么实现网络IO高并发编程？
## 1.66 BIO、NIO、AIO区别是什么？
- 🌟 BIO：同步阻塞：查询快递信息没有就一直等
- 🌟 NIO：同步非阻塞：银行大堂经理，谁准备好了谁就去处理业务
- 🌟 AIO：异步非阻塞：每个人叫号，谁的号到了就叫谁

## 1.67 NIO是怎么实现的？
## 1.68 你知道有哪个框架用到NIO了吗？
## 1.69 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？
```java
students.sort(
	Comparator.comparingInt((Student s) -> s.score).reversed()
				.thenComparingInt(s -> s.id)
);
```
- `Comparator.comparingInt((Student s) -> s.score)`：先创建了一个按分数**升序**的比较器。
	
- `.reversed()`：然后立刻将这个升序比较器**逆转**，使它变成了一个按分数**降序**的比较器。
    
- `.thenComparingInt(s -> s.id)`：最后再追加一个规则，如果分数相同，就按学号**升序**（`thenComparingInt`默认也是升序）。
## 1.70 Native方法解释一下
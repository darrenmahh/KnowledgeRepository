<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式链表节点交换模拟器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <style>
        body {
            font-family: 'Inter', 'Microsoft YaHei', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .node {
            width: 60px;
            height: 60px;
            border: 2px solid #0ea5e9; /* sky-500 */
            background-color: #f0f9ff; /* sky-50 */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: bold;
            color: #0c4a6e; /* sky-900 */
            position: absolute;
            transition: all 0.5s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .node-dummy {
             background-color: #f1f5f9; /* slate-100 */
             border-color: #64748b; /* slate-500 */
             color: #475569; /* slate-600 */
        }
        .line {
            position: absolute;
            height: 2px;
            background-color: #475569; /* slate-600 */
            transform-origin: left center;
            transition: all 0.5s ease-in-out;
            z-index: -1;
        }
        .arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 15px solid #475569; /* slate-600 */
            transition: all 0.5s ease-in-out;
            z-index: 1;
        }
        .pointer-label {
            position: absolute;
            background-color: #fecaca; /* red-200 */
            color: #991b1b; /* red-800 */
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.5s ease-in-out;
            border: 1px solid #f87171; /* red-400 */
        }
        .highlight-first {
            border-color: #fb923c; /* orange-400 */
            box-shadow: 0 0 20px rgba(251, 146, 60, 0.7);
        }
        .highlight-second {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.7);
        }
        /* --- Styles for highlighting the active link --- */
        .line-active {
            background-color: #ef4444; /* red-500 */
            height: 4px; /* Make the line thicker */
        }
        .arrow-active {
            border-left-color: #ef4444; /* red-500 */
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 18px solid #ef4444;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-800">交互式链表节点交换</h1>
            <p class="text-md text-slate-600 mt-2">手动分步操作，观察指针的真实变化，而非简单的数值交换。</p>
        </header>

        <!-- Visualization Area -->
        <div id="viz-container" class="relative w-full h-64 md:h-80 bg-white rounded-lg shadow-inner border border-slate-200 mb-6">
            <!-- Nodes and lines will be injected here by JS -->
        </div>

        <!-- Controls and Explanation -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1 flex flex-col items-center justify-center bg-white p-6 rounded-lg shadow-md border">
                <h2 class="text-xl font-bold text-slate-700 mb-4">控制面板</h2>
                <button id="reset-btn" class="w-full bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600 transition-colors mb-3">创建/重置链表</button>
                <button id="next-step-btn" class="w-full bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors" disabled>下一步</button>
            </div>
            <div id="explanation-box" class="md:col-span-2 bg-white p-6 rounded-lg shadow-md border flex items-center justify-center min-h-[120px]">
                <p id="explanation-text" class="text-slate-600 text-center text-lg">点击“创建/重置链表”开始模拟。</p>
            </div>
        </div>
    </div>

    <script>
        const vizContainer = document.getElementById('viz-container');
        const resetBtn = document.getElementById('reset-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const explanationText = document.getElementById('explanation-text');

        let nodes = [];
        let swapGenerator = null;
        let lastState = {};
        
        // --- Core Algorithm: Generator for step-by-step execution ---
        function* swapPairsGenerator() {
            const dummyHead = nodes[0];
            let prev = dummyHead;
            let current = dummyHead.next;
            yield { 
                pointers: { prev: prev.id, current: current ? current.id : null },
                explanation: "初始化：创建一个虚拟头节点(dummy)，让 prev 指向它，current 指向真正的头节点。",
                active_link: null
            };

            while (current && current.next) {
                const firstNode = current;
                const secondNode = current.next;

                yield {
                    pointers: { prev: prev.id, first: firstNode.id, second: secondNode.id },
                    explanation: `识别到要交换的节点对：(${firstNode.value}, ${secondNode.value})`,
                    active_link: null
                };
                
                // Step 1: prev.next -> secondNode
                prev.next = secondNode;
                yield {
                    pointers: { prev: prev.id, first: firstNode.id, second: secondNode.id },
                    explanation: `第 1 步：将前序节点 (prev) 的 next 指向第二节点 (${secondNode.value})。`,
                    active_link: prev.id
                };

                // Step 2: firstNode.next -> secondNode.next
                firstNode.next = secondNode.next;
                yield {
                    pointers: { prev: prev.id, first: firstNode.id, second: secondNode.id },
                    explanation: `第 2 步：将第一节点 (${firstNode.value}) 的 next 指向原第二节点的下一个节点。`,
                    active_link: firstNode.id
                };

                // Step 3: secondNode.next -> firstNode
                secondNode.next = firstNode;
                yield {
                    pointers: { prev: prev.id, first: firstNode.id, second: secondNode.id },
                    explanation: `第 3 步：将第二节点 (${secondNode.value}) 的 next 指向第一节点 (${firstNode.value})，完成交换！`,
                    active_link: secondNode.id
                };
                
                // Update pointers for the next iteration
                prev = firstNode;
                current = firstNode.next;
                yield {
                    pointers: { prev: prev.id, current: current ? current.id : null },
                    explanation: "更新指针：移动 prev 和 current，为下一轮交换做准备。",
                    active_link: null
                };
            }
            
            yield {
                pointers: {},
                explanation: "遍历完成，所有相邻节点已成功交换！",
                active_link: null
            };
            nextStepBtn.disabled = true;
        }


        // --- Visualization Logic ---
        function createAndRenderList() {
            nodes = [];
            nodes.push({ id: 0, value: 'D', next: null, isDummy: true });
            
            const listValues = [11, 22, 33, 44, 55, 66];
            for (let i = 0; i < listValues.length; i++) {
                nodes.push({ id: i + 1, value: listValues[i], next: null });
            }

            for (let i = 0; i < nodes.length - 1; i++) {
                nodes[i].next = nodes[i + 1];
            }
            
            swapGenerator = swapPairsGenerator();
            explanationText.textContent = "链表已创建。点击“下一步”开始交换。";
            nextStepBtn.disabled = false;
            
            lastState = {};
            updateVisualization(lastState);
        }

        function updateVisualization(state) {
            lastState = state; // Keep track of the current state for resizing
            vizContainer.innerHTML = '';
            const containerWidth = vizContainer.clientWidth;
            const containerHeight = vizContainer.clientHeight;
            const nodeCount = nodes.length;
            const spacing = Math.min(120, (containerWidth - 80) / (nodeCount - 1));

            // Position and draw nodes
            nodes.forEach((node, i) => {
                node.x = 40 + i * spacing;
                node.y = containerHeight / 2;
                const nodeEl = document.createElement('div');
                nodeEl.id = `node-${node.id}`;
                nodeEl.className = 'node';
                if (node.isDummy) nodeEl.classList.add('node-dummy');
                nodeEl.textContent = node.value;
                nodeEl.style.left = `${node.x - 30}px`;
                nodeEl.style.top = `${node.y - 30}px`;
                if (state.pointers && state.pointers.first === node.id) nodeEl.classList.add('highlight-first');
                if (state.pointers && state.pointers.second === node.id) nodeEl.classList.add('highlight-second');
                vizContainer.appendChild(nodeEl);
            });

            // Draw lines and arrows
            nodes.forEach(node => {
                if (node.next) {
                    const startNode = node;
                    const endNode = node.next;
                    const startX = startNode.x + 30;
                    const startY = startNode.y;
                    const endX = endNode.x - 30;
                    const endY = endNode.y;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));

                    const lineEl = document.createElement('div');
                    lineEl.className = 'line';
                    const arrowEl = document.createElement('div');
                    arrowEl.className = 'arrow';
                    
                    // Highlight the active link
                    if (state.active_link === startNode.id) {
                        lineEl.classList.add('line-active');
                        arrowEl.classList.add('arrow-active');
                    }
                    
                    lineEl.style.width = `${length}px`;
                    lineEl.style.left = `${startX}px`;
                    lineEl.style.top = `${startY}px`;
                    lineEl.style.transform = `rotate(${angle}rad)`;
                    vizContainer.appendChild(lineEl);

                    arrowEl.style.left = `${endX - 15}px`;
                    arrowEl.style.top = `${endY - 8}px`;
                    arrowEl.style.transform = `rotate(${angle}rad)`;
                    vizContainer.appendChild(arrowEl);
                }
            });

            // Draw pointer labels
            if(state.pointers) {
                const pointerNames = Object.keys(state.pointers);
                pointerNames.forEach(pName => {
                    const nodeId = state.pointers[pName];
                    const node = nodes.find(n => n.id === nodeId);
                    if (node) {
                        const labelEl = document.createElement('div');
                        labelEl.className = 'pointer-label';
                        labelEl.textContent = pName;
                        labelEl.style.left = `${node.x - 15}px`;
                        labelEl.style.top = `${node.y - 70}px`;
                        vizContainer.appendChild(labelEl);
                    }
                });
            }
        }

        // --- Event Listeners ---
        resetBtn.addEventListener('click', createAndRenderList);

        nextStepBtn.addEventListener('click', () => {
            if (swapGenerator) {
                const result = swapGenerator.next();
                if (!result.done) {
                    updateVisualization(result.value);
                    explanationText.textContent = result.value.explanation;
                } else {
                    nextStepBtn.disabled = true;
                    explanationText.textContent = "模拟结束！";
                }
            }
        });

        window.addEventListener('resize', () => {
            if (nodes.length > 0) {
                 updateVisualization(lastState);
                 explanationText.textContent = "请继续操作..."
            }
        });
        
    </script>
</body>
</html>
